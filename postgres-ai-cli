#!/bin/bash

# PostgreSQL AI CLI
# A CLI tool for managing the PostgreSQL monitoring system with Docker Compose

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_NAME="postgres-ai-mon"
COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
PYTHON_REQUIREMENTS="$SCRIPT_DIR/requirements.txt"
INSTANCES_FILE="$SCRIPT_DIR/instances.yml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Print banner
print_banner() {
    echo -e "${BLUE}"
    echo "=================================="
    echo "  PostgreSQL AI CLI"
    echo "=================================="
    echo -e "${NC}"
}

# Show help
show_help() {
    print_banner
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo
    echo "COMMANDS:"
    echo "  install [--demo]    Clone repository and setup the monitoring project"
    echo "  start               Start all monitoring services using Docker Compose"
    echo "  stop                Stop all services"
    echo "  restart             Restart all services"
    echo "  status              Show status of all services"
    echo "  logs [SERVICE]      Show logs for all services or specific service"
    echo "  health              Check health of all services"
    echo "  config              Show current configuration"
    echo "  update-config       Update configuration files"
    echo "  reset               Stop services and remove all data"
    echo "  clean               Clean up temporary files and unused Docker resources"
    echo "  shell [SERVICE]     Open shell in specified service container"
    echo ""
    echo "INSTANCE MANAGEMENT:"
    echo "  list-instances                    List all configured PostgreSQL instances"
    echo "  add-instance [CONN_STR] [NAME]    Add a new PostgreSQL instance for monitoring"
    echo "  remove-instance <NAME>            Remove a PostgreSQL instance"
    echo "  test-instance <NAME>              Test connection to a PostgreSQL instance"
    echo ""
    echo "API KEY MANAGEMENT:"
    echo "  add-key <api_key>              Add PostgreSQL AI API key for report uploads"
    echo "  show-key                       Show current API key (masked)"
    echo "  remove-key                     Remove stored API key"
    echo ""
    echo "  help                Show this help message"
    echo
    echo "EXAMPLES:"
    echo "  $0 install                    # Clone repository and setup for production"
    echo "  $0 install --demo            # Clone repository and setup with demo database"
    echo "  $0 start                      # Start monitoring services"
    echo "  $0 logs pgwatch-postgres     # Show logs for postgres pgwatch instance"
    echo "  $0 health                    # Check if all services are healthy"
    echo "  $0 shell target-db           # Open shell in target database (demo mode only)"
    echo ""
    echo "INSTANCE MANAGEMENT EXAMPLES:"
    echo "  $0 list-instances            # Show all configured instances"
    echo "  $0 add-instance              # Interactively add a new PostgreSQL instance"
    echo "  $0 test-instance prod-db     # Test connection to 'prod-db' instance"
    echo "  $0 remove-instance old-db    # Remove 'old-db' instance"
    echo ""
    echo "WORKFLOW:"
    echo "  PRODUCTION MODE:"
    echo "    1. Run '$0 install' to setup monitoring infrastructure"
    echo "    2. Add your PostgreSQL instances: '$0 add-instance postgresql://user:pass@host:port/db'"
    echo "    3. Start monitoring: '$0 start'"
    echo ""
    echo "  DEMO MODE:"
    echo "    1. Run '$0 install --demo' to setup with demo database included"
    echo "    2. Start all services: '$0 start'"
    echo "    3. Access demo database at localhost:5432"
    echo ""
    echo "  The CLI auto-detects project directory from any location"
    echo
    echo "SERVICES:"
    echo "  sink-postgres       PostgreSQL sink for storing metrics"
    echo "  sink-prometheus     Prometheus sink for storing metrics"
    echo "  pgwatch-postgres    PGWatch instance with PostgreSQL sink"
    echo "  pgwatch-prometheus  PGWatch instance with Prometheus sink"
    echo "  grafana             Grafana dashboard interface"
    echo "  flask-backend       Flask API backend"
    echo "  postgres-reports    PostgreSQL reports generator (runs every 24h)"
    echo "  target-db           Demo PostgreSQL database (--demo mode only)"
    echo
    echo "ACCESS URLS:"
    echo "  Grafana:           http://localhost:3000 (admin/admin)"
    echo "  PGWatch Postgres:  http://localhost:8080"
    echo "  PGWatch Prometheus: http://localhost:8089"
    echo "  Prometheus:        http://localhost:9090"
    echo "  Flask API:         http://localhost:5000"
    echo "  Sink DB:           postgresql://postgres:postgres@localhost:5433/postgres"
    echo "  Demo DB:           postgresql://postgres:postgres@localhost:5432/target_database (--demo mode only)"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    local missing_deps=()
    
    # Check Git
    if ! command -v git &> /dev/null; then
        missing_deps+=("git")
    fi
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        missing_deps+=("docker")
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
        missing_deps+=("docker-compose")
    fi
    
    # Future: Check Python when reports functionality is added
    # if ! command -v python3 &> /dev/null; then
    #     missing_deps+=("python3")
    # fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        echo
        echo "Please install the missing dependencies:"
        echo "  macOS: brew install git docker docker-compose"
        echo "  Ubuntu/Debian: apt-get install git docker.io docker-compose"
        echo "  CentOS/RHEL: yum install git docker docker-compose"
        exit 1
    fi
    
    log_success "All prerequisites are installed"
}

# Check if demo mode is enabled
is_demo_mode() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep -q "demo_mode=true" "$SCRIPT_DIR/.pgwatch-config"
        return $?
    fi
    # Default to false if config file doesn't exist
    return 1
}

# API Key Management Functions

# Add API key to configuration
add_api_key() {
    local api_key="$1"
    
    if [ -z "$api_key" ]; then
        log_error "Please provide an API key"
        echo "Usage: $0 add-key <api_key>"
        exit 1
    fi
    
    # Create config file if it doesn't exist
    touch "$SCRIPT_DIR/.pgwatch-config"
    
    # Remove existing api_key line if present
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep -v "^api_key=" "$SCRIPT_DIR/.pgwatch-config" > "$SCRIPT_DIR/.pgwatch-config.tmp" || true
        mv "$SCRIPT_DIR/.pgwatch-config.tmp" "$SCRIPT_DIR/.pgwatch-config"
    fi
    
    # Add the new API key
    echo "api_key=$api_key" >> "$SCRIPT_DIR/.pgwatch-config"
    
    log_success "API key added successfully"
    log_info "The API key will be used for automatic report uploads"
}

# Show API key (masked for security)
show_api_key() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        local api_key=$(grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$api_key" ]; then
            local masked_key="${api_key:0:4}$( printf '%*s' $((${#api_key} - 8)) '' | tr ' ' '*' )${api_key: -4}"
            log_info "Current API key: $masked_key"
        else
            log_warning "No API key configured"
        fi
    else
        log_warning "No API key configured"
    fi
}

# Remove API key from configuration
remove_api_key() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep -v "^api_key=" "$SCRIPT_DIR/.pgwatch-config" > "$SCRIPT_DIR/.pgwatch-config.tmp" || true
        mv "$SCRIPT_DIR/.pgwatch-config.tmp" "$SCRIPT_DIR/.pgwatch-config"
        log_success "API key removed successfully"
    else
        log_warning "No API key configured"
    fi
}

# Get API key from configuration
get_api_key() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2
    fi
}

# Detect project directory
detect_project_dir() {
    # Check if we're already in the project directory
    if [ -f "$SCRIPT_DIR/docker-compose.yml" ] && [ -f "$SCRIPT_DIR/instances.yml" ]; then
        return 0
    fi
    
    # Check if postgres_ai directory exists in current location
    if [ -d "$SCRIPT_DIR/postgres_ai" ] && [ -f "$SCRIPT_DIR/postgres_ai/docker-compose.yml" ]; then
        SCRIPT_DIR="$SCRIPT_DIR/postgres_ai"
        COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
        PYTHON_REQUIREMENTS="$SCRIPT_DIR/requirements.txt"
        INSTANCES_FILE="$SCRIPT_DIR/instances.yml"
        return 0
    fi
    
    # Project not found
    return 1
}

# Future: Install Python dependencies for reports
install_dependencies() {
    log_info "Skipping Python dependencies installation (only Docker monitoring for now)"
}

# Clone repository if needed
clone_repository() {
    local repo_url="https://gitlab.com/postgres-ai/postgres_ai.git"
    local project_dir="postgres_ai"
    
    # Check if we're already in the project directory
    if [ -f "$SCRIPT_DIR/docker-compose.yml" ] && [ -f "$SCRIPT_DIR/instances.yml" ]; then
        log_info "Project files already exist, skipping clone"
        return 0
    fi
    
    # Check if project directory already exists
    if [ -d "$project_dir" ]; then
        log_warning "Directory '$project_dir' already exists"
        read -p "Remove it and clone fresh? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            rm -rf "$project_dir"
        else
            log_info "Using existing directory"
            cd "$project_dir" || exit 1
            return 0
        fi
    fi
    
    log_info "Cloning PostgreSQL AI project from GitLab..."
    if git clone "$repo_url" "$project_dir"; then
        log_success "Repository cloned successfully"
        cd "$project_dir" || exit 1
        # Update SCRIPT_DIR to the cloned directory
        SCRIPT_DIR="$(pwd)"
        COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
        PYTHON_REQUIREMENTS="$SCRIPT_DIR/requirements.txt"
        INSTANCES_FILE="$SCRIPT_DIR/instances.yml"
    else
        log_error "Failed to clone repository"
        exit 1
    fi
}

# Install and setup
install_project() {
    local demo_mode=false
    
    # Check for --demo flag
    if [ "$1" = "--demo" ]; then
        demo_mode=true
        log_info "Demo mode enabled - will include target demo database"
    fi
    
    print_banner
    log_info "Setting up PostgreSQL AI monitoring project..."
    
    check_prerequisites
    clone_repository
    install_dependencies
    
    # Create necessary directories
    mkdir -p "$SCRIPT_DIR/config/pgwatch-postgres"
    mkdir -p "$SCRIPT_DIR/config/pgwatch-prometheus"
    
    # Store demo mode setting
    if [ "$demo_mode" = true ]; then
        echo "demo_mode=true" > "$SCRIPT_DIR/.pgwatch-config"
        log_info "Target demo database will be included for testing"
    else
        echo "demo_mode=false" > "$SCRIPT_DIR/.pgwatch-config"
        log_info "Production mode - only monitoring infrastructure will be started"
        log_warning "You'll need to add your own PostgreSQL instances to monitor"
        

    fi
    
    log_success "Setup completed!"
    log_info "Project location: $SCRIPT_DIR"
    
    if [ "$demo_mode" = true ]; then
        log_info "You can now start all services (including demo database) with: $0 start"
        log_info "The demo database will be available at: postgresql://postgres:postgres@localhost:5432/target_database"
    else
        log_info "You can now:"
        echo "  1. Add PostgreSQL instances to monitor: $0 add-instance 'postgresql://user:pass@host:port/db'"
        echo "  2. Start monitoring services: $0 start"
    fi
    
    echo
    log_info "To use the CLI from the project directory:"
    echo "  cd $(basename "$SCRIPT_DIR")"
    echo "  ../postgres-ai-cli start"
}

# Get docker compose command
get_compose_cmd() {
    if command -v docker-compose &> /dev/null; then
        echo "docker-compose"
    else
        echo "docker compose"
    fi
}

# Start services
start_services() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local compose_cmd=$(get_compose_cmd)
    
    cd "$SCRIPT_DIR"
    
    if is_demo_mode; then
        log_info "Starting PostgreSQL AI services (demo mode - including target database)..."
        $compose_cmd -f "$COMPOSE_FILE" up -d
    else
        log_info "Starting PostgreSQL AI monitoring services (production mode)..."
        log_info "Target demo database not included - add your own PostgreSQL instances to monitor"
        # Start all services except target-db
        $compose_cmd -f "$COMPOSE_FILE" up -d sources-generator sink-postgres sink-prometheus pgwatch-postgres pgwatch-prometheus grafana flask-backend
    fi
    
    log_success "Services started!"
    log_info "Waiting for services to be ready..."
    sleep 10
    
    show_access_info
}

# Stop services
stop_services() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local compose_cmd=$(get_compose_cmd)
    log_info "Stopping PostgreSQL AI services..."
    
    cd "$SCRIPT_DIR"
    $compose_cmd -f "$COMPOSE_FILE" down
    
    log_success "Services stopped"
}

# Restart services
restart_services() {
    stop_services
    sleep 2
    start_services
}

# Show service status
show_status() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local compose_cmd=$(get_compose_cmd)
    log_info "PostgreSQL AI Monitoring service status:"
    echo
    
    cd "$SCRIPT_DIR"
    $compose_cmd -f "$COMPOSE_FILE" ps
}

# Show logs
show_logs() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local compose_cmd=$(get_compose_cmd)
    local service="$1"
    
    cd "$SCRIPT_DIR"
    if [ -n "$service" ]; then
        log_info "Showing logs for service: $service"
        $compose_cmd -f "$COMPOSE_FILE" logs -f "$service"
    else
        log_info "Showing logs for all services"
        $compose_cmd -f "$COMPOSE_FILE" logs -f
    fi
}

# Health check
health_check() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    log_info "Performing health checks..."
    
    local services=(
        "sink-postgres:5433:PostgreSQL Sink"
        "pgwatch-postgres:8080:PGWatch PostgreSQL"
        "pgwatch-prometheus:8089:PGWatch Prometheus"
        "sink-prometheus:9090:Prometheus"
        "grafana:3000:Grafana"
        "flask-backend:5000:Flask API"
    )
    
    # Add target-db only in demo mode
    if is_demo_mode; then
        services=("target-db:5432:PostgreSQL Target Database" "${services[@]}")
    fi
    
    local all_healthy=true
    
    for service_info in "${services[@]}"; do
        IFS=':' read -r service port description <<< "$service_info"
        
        if curl -s -o /dev/null -w "%{http_code}" "http://localhost:$port" | grep -q "200\|302"; then
            log_success "$description is healthy"
        else
            log_error "$description is not responding"
            all_healthy=false
        fi
    done
    
    if [ "$all_healthy" = true ]; then
        log_success "All services are healthy!"
        show_access_info
    else
        log_warning "Some services are not healthy. Check the logs with: $0 logs"
    fi
}

# List all configured instances
list_instances() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    if [ ! -f "$INSTANCES_FILE" ]; then
        log_warning "No instances file found at $INSTANCES_FILE"
        return 1
    fi
    
    log_info "Configured PostgreSQL instances:"
    echo
    
    # Parse instances.yml and display in a readable format
    local in_instance=false
    local name=""
    local conn_str=""
    local is_enabled=""
    local env=""
    local cluster=""
    local node_name=""
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^-[[:space:]]*name:[[:space:]]*(.+)$ ]]; then
            # New instance starts
            if [ -n "$name" ]; then
                # Display previous instance
                echo "  ðŸ“ Instance: $name"
                echo "     Connection: $conn_str"
                echo "     Status: ${is_enabled:-unknown}"
                [ -n "$env" ] && echo "     Environment: $env"
                [ -n "$cluster" ] && echo "     Cluster: $cluster"
                [ -n "$node_name" ] && echo "     Node: $node_name"
                echo
            fi
            name="${BASH_REMATCH[1]}"
            conn_str=""
            is_enabled=""
            env=""
            cluster=""
            node_name=""
        elif [[ "$line" =~ ^[[:space:]]*conn_str:[[:space:]]*(.+)$ ]]; then
            conn_str="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*is_enabled:[[:space:]]*(.+)$ ]]; then
            is_enabled="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*env:[[:space:]]*(.+)$ ]]; then
            env="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*cluster:[[:space:]]*(.+)$ ]]; then
            cluster="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*node_name:[[:space:]]*(.+)$ ]]; then
            node_name="${BASH_REMATCH[1]}"
        fi
    done < "$INSTANCES_FILE"
    
    # Display last instance
    if [ -n "$name" ]; then
        echo "  ðŸ“ Instance: $name"
        echo "     Connection: $conn_str"
        echo "     Status: ${is_enabled:-unknown}"
        [ -n "$env" ] && echo "     Environment: $env"
        [ -n "$cluster" ] && echo "     Cluster: $cluster"
        [ -n "$node_name" ] && echo "     Node: $node_name"
        echo
    fi
}

# Parse connection string into components
parse_connection_string() {
    local conn_str="$1"
    
    # postgresql://user:password@host:port/database
    if [[ "$conn_str" =~ ^postgresql://([^:]+):([^@]+)@([^:]+):([0-9]+)/(.+)$ ]]; then
        PG_USER="${BASH_REMATCH[1]}"
        PG_PASSWORD="${BASH_REMATCH[2]}"
        PG_HOST="${BASH_REMATCH[3]}"
        PG_PORT="${BASH_REMATCH[4]}"
        PG_DATABASE="${BASH_REMATCH[5]}"
        return 0
    # postgresql://user:password@host/database (default port)
    elif [[ "$conn_str" =~ ^postgresql://([^:]+):([^@]+)@([^/]+)/(.+)$ ]]; then
        PG_USER="${BASH_REMATCH[1]}"
        PG_PASSWORD="${BASH_REMATCH[2]}"
        PG_HOST="${BASH_REMATCH[3]}"
        PG_PORT="5432"
        PG_DATABASE="${BASH_REMATCH[4]}"
        return 0
    else
        return 1
    fi
}

# Add a new PostgreSQL instance
add_instance() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local conn_str="$1"
    local instance_name="$2"
    
    # If connection string provided, parse it
    if [ -n "$conn_str" ]; then
        log_info "Adding PostgreSQL instance from connection string..."
        
        if ! parse_connection_string "$conn_str"; then
            log_error "Invalid connection string format"
            log_info "Expected format: postgresql://user:password@host:port/database"
            log_info "Example: postgresql://myuser:mypass@localhost:5432/mydb"
            exit 1
        fi
        
        # Use provided instance name or derive from host
        if [ -z "$instance_name" ]; then
            instance_name="$PG_HOST-$PG_DATABASE"
            instance_name=$(echo "$instance_name" | sed 's/[^a-zA-Z0-9-]/-/g')
        fi
        
        # Set default values
        environment="production"
        cluster_name="default"
        node_name="$instance_name"
        is_enabled="true"
        
        log_info "Parsed connection details:"
        echo "  Instance name: $instance_name"
        echo "  Host: $PG_HOST"
        echo "  Port: $PG_PORT"
        echo "  Database: $PG_DATABASE"
        echo "  User: $PG_USER"
        echo
        
    else
        # Interactive mode
        log_info "Adding a new PostgreSQL instance for monitoring (interactive mode)"
        echo
        log_info "Tip: You can also use: $0 add-instance 'postgresql://user:pass@host:port/db' [instance-name]"
        echo
        
        # Collect instance details
        read -p "Instance unique name: " instance_name
        if [ -z "$instance_name" ]; then
            log_error "Instance name is required"
            exit 1
        fi
        
        read -p "PostgreSQL host/IP: " PG_HOST
        if [ -z "$PG_HOST" ]; then
            log_error "PostgreSQL host is required"
            exit 1
        fi
        
        read -p "PostgreSQL port [5432]: " PG_PORT
        PG_PORT=${PG_PORT:-5432}
        
        read -p "Database name: " PG_DATABASE
        if [ -z "$PG_DATABASE" ]; then
            log_error "Database name is required"
            exit 1
        fi
        
        read -p "Username: " PG_USER
        if [ -z "$PG_USER" ]; then
            log_error "Username is required"
            exit 1
        fi
        
        read -s -p "Password: " PG_PASSWORD
        echo
        if [ -z "$PG_PASSWORD" ]; then
            log_error "Password is required"
            exit 1
        fi
        
        environment=${environment:-production}
        
        read -p "Cluster name [default]: " cluster_name
        cluster_name=${cluster_name:-default}
        
        read -p "Node name [$instance_name]: " node_name
        node_name=${node_name:-$instance_name}
        
        read -p "Enable monitoring? [Y/n]: " enable_monitoring
        if [[ $enable_monitoring =~ ^[Nn]$ ]]; then
            is_enabled="false"
        else
            is_enabled="true"
        fi
        
        # Build connection string for verification
        conn_str="postgresql://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DATABASE"
    fi
    
    # Check if instance already exists
    if grep -q "name: $instance_name" "$INSTANCES_FILE" 2>/dev/null; then
        log_error "Instance '$instance_name' already exists"
        exit 1
    fi
    
    # Create new instance configuration
    local new_instance="
- name: $instance_name
  conn_str: postgresql://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DATABASE
  preset_metrics: full
  custom_metrics:
  is_enabled: $is_enabled
  group: default
  custom_tags:
    env: $environment
    cluster: $cluster_name
    node_name: $node_name
    sink_type: ~sink_type~"
    
    # Add to instances file
    echo "$new_instance" >> "$INSTANCES_FILE"
    
    log_success "Instance '$instance_name' added successfully!"
    log_info "You can test the connection with: $0 test-instance $instance_name"
    log_info "Run '$0 update-config' to apply the new configuration"
}

# Remove a PostgreSQL instance
remove_instance() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        log_error "Please specify an instance name to remove"
        log_info "Usage: $0 remove-instance <instance_name>"
        log_info "Use '$0 list-instances' to see available instances"
        exit 1
    fi
    
    if ! grep -q "name: $instance_name" "$INSTANCES_FILE" 2>/dev/null; then
        log_error "Instance '$instance_name' not found"
        exit 1
    fi
    
    log_warning "This will remove instance '$instance_name' from monitoring"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Create temporary file without the instance
        local temp_file=$(mktemp)
        local skip_lines=false
        local instance_started=false
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^-[[:space:]]*name:[[:space:]]*$instance_name$ ]]; then
                skip_lines=true
                instance_started=true
            elif [[ "$line" =~ ^-[[:space:]]*name: ]] && [ "$skip_lines" = true ]; then
                skip_lines=false
                echo "$line" >> "$temp_file"
            elif [ "$skip_lines" = false ]; then
                echo "$line" >> "$temp_file"
            fi
        done < "$INSTANCES_FILE"
        
        mv "$temp_file" "$INSTANCES_FILE"
        log_success "Instance '$instance_name' removed successfully"
        log_info "Run '$0 update-config' to apply the changes"
    else
        log_info "Removal cancelled"
    fi
}

# Test connection to a PostgreSQL instance
test_instance() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        log_error "Please specify an instance name to test"
        log_info "Usage: $0 test-instance <instance_name>"
        log_info "Use '$0 list-instances' to see available instances"
        exit 1
    fi
    
    # Extract connection string for the instance
    local conn_str=""
    local in_instance=false
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^-[[:space:]]*name:[[:space:]]*$instance_name$ ]]; then
            in_instance=true
        elif [[ "$line" =~ ^-[[:space:]]*name: ]] && [ "$in_instance" = true ]; then
            break
        elif [[ "$line" =~ ^[[:space:]]*conn_str:[[:space:]]*(.+)$ ]] && [ "$in_instance" = true ]; then
            conn_str="${BASH_REMATCH[1]}"
            break
        fi
    done < "$INSTANCES_FILE"
    
    if [ -z "$conn_str" ]; then
        log_error "Instance '$instance_name' not found or missing connection string"
        exit 1
    fi
    
    log_info "Testing connection to instance: $instance_name"
    log_info "Connection string: $conn_str"
    
    # Test connection using Docker PostgreSQL client
    if command -v psql &> /dev/null; then
        echo "SELECT version();" | psql "$conn_str" 2>/dev/null
        if [ $? -eq 0 ]; then
            log_success "Connection to '$instance_name' successful!"
        else
            log_error "Connection to '$instance_name' failed!"
        fi
    else
        log_warning "psql not found locally. Testing via Docker..."
        local compose_cmd=$(get_compose_cmd)
        cd "$SCRIPT_DIR"
        
        if $compose_cmd -f "$COMPOSE_FILE" exec -T target-db psql "$conn_str" -c "SELECT version();" 2>/dev/null; then
            log_success "Connection to '$instance_name' successful!"
        else
            log_error "Connection to '$instance_name' failed!"
            log_info "Make sure the database is accessible and credentials are correct"
        fi
    fi
}

# Future: Generate reports functionality will be added here

# Show configuration
show_config() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    log_info "Current configuration:"
    echo
    echo "Project Directory: $SCRIPT_DIR"
    echo "Docker Compose File: $COMPOSE_FILE"
    echo "Instances File: $INSTANCES_FILE"
    echo
    
    if [ -f "$INSTANCES_FILE" ]; then
        log_info "Instances configuration:"
        cat "$INSTANCES_FILE"
    else
        log_warning "Instances file not found"
    fi
}

# Update configuration
update_config() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    log_info "Updating configuration files..."
    
    # Generate sources files
    local compose_cmd=$(get_compose_cmd)
    cd "$SCRIPT_DIR"
    $compose_cmd -f "$COMPOSE_FILE" run --rm sources-generator
    $compose_cmd -f "$COMPOSE_FILE" restart pgwatch-postgres
    $compose_cmd -f "$COMPOSE_FILE" restart pgwatch-prometheus
    
    log_success "Configuration updated"
}

# Reset environment
reset_environment() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    log_warning "This will stop all services and remove all data!"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local compose_cmd=$(get_compose_cmd)
        cd "$SCRIPT_DIR"
        
        log_info "Stopping services and removing data..."
        $compose_cmd -f "$COMPOSE_FILE" down -v
        
        # Remove any generated config files
        rm -f "$SCRIPT_DIR/config/pgwatch-postgres/sources.yml"
        rm -f "$SCRIPT_DIR/config/pgwatch-prometheus/sources.yml"
        
        log_success "Environment reset completed"
    else
        log_info "Reset cancelled"
    fi
}

# Clean up
cleanup() {
    log_info "Cleaning up..."
    
    # Remove Python cache
    find "$SCRIPT_DIR" -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
    find "$SCRIPT_DIR" -name "*.pyc" -type f -delete 2>/dev/null || true
    
    # Clean Docker resources
    docker system prune -f
    
    log_success "Cleanup completed"
}

# Open shell in container
open_shell() {
    if ! detect_project_dir; then
        log_error "Project files not found. Please run: $0 install"
        exit 1
    fi
    
    local service="$1"
    
    if [ -z "$service" ]; then
        log_error "Please specify a service name"
        log_info "Available services: target-db, sink-postgres, sink-prometheus, pgwatch-postgres, pgwatch-prometheus, grafana, flask-backend, postgres-reports"
        exit 1
    fi
    
    local compose_cmd=$(get_compose_cmd)
    cd "$SCRIPT_DIR"
    
    if [ "$service" = "target-db" ] || [ "$service" = "sink-postgres" ]; then
        $compose_cmd -f "$COMPOSE_FILE" exec "$service" psql -U postgres
    else
        $compose_cmd -f "$COMPOSE_FILE" exec "$service" /bin/sh
    fi
}

# Show access information
show_access_info() {
    echo
    log_info "Access URLs:"
    echo "  Grafana:            http://localhost:3000 (admin/admin)"
    echo "  PGWatch Postgres:   http://localhost:8080"
    echo "  PGWatch Prometheus: http://localhost:8089"
    echo "  Prometheus:         http://localhost:9090"
    echo "  Flask API:          http://localhost:5000"
    
    # Show target database only in demo mode
    if is_demo_mode; then
        echo "  Target Database:    postgresql://postgres:postgres@localhost:5432/target_database"
    fi
    
    echo "  Sink Database:      postgresql://postgres:postgres@localhost:5433/postgres"
    echo
    
    # Show reports information
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ] && grep -q "^api_key=" "$SCRIPT_DIR/.pgwatch-config"; then
        log_info "PostgreSQL reports will be generated every 24 hours and uploaded to PostgreSQL AI"
        local api_key=$(grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        local masked_key="${api_key:0:4}$( printf '%*s' $((${#api_key} - 8)) '' | tr ' ' '*' )${api_key: -4}"
        echo "  API Key:            $masked_key"
    else
        log_info "PostgreSQL reports will be generated every 24 hours (no API key configured for upload)"
        log_info "Use '$0 add-key <api_key>' to enable automatic report uploads"
    fi
    echo
    
    if ! is_demo_mode; then
        log_info "Production mode - no demo database running"
        log_info "Use '$0 list-instances' to see your configured PostgreSQL instances"
    fi
}

# Main command handling
main() {
    case "${1:-help}" in
        "install")
            install_project "$2"
            ;;
        "start")
            start_services
            ;;
        "stop")
            stop_services
            ;;
        "restart")
            restart_services
            ;;
        "status")
            show_status
            ;;
        "logs")
            show_logs "$2"
            ;;
        "health")
            health_check
            ;;
        "config")
            show_config
            ;;
        "update-config")
            update_config
            ;;
        "reset")
            reset_environment
            ;;
        "clean")
            cleanup
            ;;
        "shell")
            open_shell "$2"
            ;;
        "list-instances")
            list_instances
            ;;
        "add-instance")
            add_instance "$2" "$3"
            ;;
        "remove-instance")
            remove_instance "$2"
            ;;
        "test-instance")
            test_instance "$2"
            ;;
        "add-key")
            add_api_key "$2"
            ;;
        "show-key")
            show_api_key
            ;;
        "remove-key")
            remove_api_key
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        *)
            log_error "Unknown command: $1"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 