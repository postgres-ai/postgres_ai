# Simple PGWatch Metrics for Prometheus - just queryid and calls

# The following structure is expected for metrics and preset definitions:
# metrics:
#    metric_name:
#        init_sql: |-
#            CREATE EXTENSION IF NOT EXISTS some_extension;
#            CREATE OR REPLACE FUNCTION get_some_stat(OUT some_stat int)
#            ...
#        sqls:
#            11: |
#                select /* pgwatch_generated */
#                  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
#                  ...
#            14: |
#                select /* pgwatch_generated */
#                  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
#                  ...
#        gauges:
#            - '*'
#        is_instance_level: true
#        node_status: primary
#        statement_timeout_seconds: 300
#        metric_storage_name: db_stats
metrics:
  backends:
    description: >
      This metric gathers detailed information from the PostgreSQL pg_stat_activity view, providing an overview of the database's current session
      and activity state. It tracks the total number of client backends, active sessions, idle sessions, sessions waiting on locks, and background workers.
      The metric also calculates statistics on blocked sessions, most extended waiting times, average and longest session durations, transaction times,
      and query durations. Additionally, it monitors autovacuum worker activity and provides the age of the oldest transaction (measured by xmin).
      This metric helps administrators monitor session states, detect bottlenecks, and ensure the system is within its connection limits,
      providing visibility into database performance and contention.
    sqls:
      11: |
        with sa_snapshot as (
          select * from pg_stat_activity
          where pid != pg_backend_pid()
          and datname = current_database()
        )
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          (select count(*) from sa_snapshot where backend_type = 'client backend') as total,
          (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,
          current_setting('max_connections')::int as max_connections,
          (select count(*) from sa_snapshot where backend_type = 'background worker') as background_workers,
          (select count(*) from sa_snapshot where state = 'active' and backend_type = 'client backend') as active,
          (select count(*) from sa_snapshot where state = 'idle' and backend_type = 'client backend') as idle,
          (select count(*) from sa_snapshot where state = 'idle in transaction' and backend_type = 'client backend') as idleintransaction,
          (select count(*) from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as waiting,
          (select coalesce(sum(case when coalesce(array_length(pg_blocking_pids(pid), 1), 0) >= 1 then 1 else 0 end), 0) from sa_snapshot where backend_type = 'client backend' and state = 'active') as blocked,
          (select ceil(extract(epoch from max(now() - query_start)))::int from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as longest_waiting_seconds,
          (select round(avg(abs(extract(epoch from now() - query_start)))::numeric, 3)::float from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as avg_waiting_seconds,
          (select ceil(extract(epoch from (now() - backend_start)))::int from sa_snapshot where backend_type = 'client backend' order by backend_start limit 1) as longest_session_seconds,
          (select round(avg(abs(extract(epoch from now() - backend_start)))::numeric, 3)::float from sa_snapshot where backend_type = 'client backend') as avg_session_seconds,
          (select ceil(extract(epoch from (now() - xact_start)))::int from sa_snapshot where xact_start is not null and backend_type = 'client backend' order by xact_start limit 1) as longest_tx_seconds,
          (select round(avg(abs(extract(epoch from now() - xact_start)))::numeric, 3)::float from sa_snapshot where xact_start is not null and backend_type = 'client backend') as avg_tx_seconds,
          (select ceil(extract(epoch from (now() - xact_start)))::int from sa_snapshot where backend_type = 'autovacuum worker' order by xact_start limit 1) as longest_autovacuum_seconds,
          (select ceil(extract(epoch from max(now() - query_start)))::int from sa_snapshot where state = 'active' and backend_type = 'client backend') as longest_query_seconds,
          (select round(avg(abs(extract(epoch from now() - query_start)))::numeric, 3)::float from sa_snapshot where state = 'active' and backend_type = 'client backend') as avg_query_seconds,
          (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx,
          (select count(*) from sa_snapshot where state = 'active' and backend_type = 'autovacuum worker') as av_workers
    gauges:
      - '*'
  bgwriter:
    description: >
      Retrieves key statistics from the PostgreSQL `pg_stat_bgwriter` view, providing insights into the background writer's performance.
      It returns the number of timed and requested checkpoints, checkpoint write and sync times, buffer statistics, and the last reset time.
      This metric helps administrators monitor the background writer's activity and its impact on database performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
            (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
            current_database() as tag_datname,
            checkpoints_timed,
            checkpoints_req,
            checkpoint_write_time,
            checkpoint_sync_time,
            buffers_checkpoint,
            buffers_clean,
            maxwritten_clean,
            buffers_backend,
            buffers_backend_fsync,
            buffers_alloc
          from
            pg_stat_bgwriter
      17: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          buffers_clean,
          maxwritten_clean,
          buffers_alloc,
          (extract(epoch from now() - stats_reset))::int as last_reset_s
        from
          pg_stat_bgwriter
    node_status: primary
    is_instance_level: true
  checkpointer:
    description: >
      Retrieves key statistics from the PostgreSQL `pg_stat_checkpointer` view, providing insights into the checkpointer's performance.
      It returns the number of timed and requested checkpoints, restart points, write and sync times, and buffer statistics.
      This metric helps administrators monitor the checkpointer's activity and its impact on database performance.
    sqls:
      11: "; -- covered by bgwriter"
      17: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          num_timed,
          num_requested,
          restartpoints_timed,
          restartpoints_req,
          restartpoints_done,
          write_time,
          sync_time,
          buffers_written,
          (extract(epoch from now() - stats_reset))::int as last_reset_s
        from
          pg_stat_checkpointer
  db_size:
    description: >
      Retrieves the size of the current database and the size of the `pg_catalog` schema, providing insights into the storage usage of the database.
      It returns the size in bytes for both the current database and the catalog schema.
      This metric helps administrators monitor database size and storage consumption.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          pg_database_size(current_database()) as size_b,
          (select sum(pg_total_relation_size(c.oid))::int8
            from pg_class c join pg_namespace n on n.oid = c.relnamespace
            where nspname = 'pg_catalog' and relkind = 'r'
          ) as catalog_size_b
    gauges:
      - '*'
    statement_timeout_seconds: 300
  db_stats:
    description: >
      Retrieves key statistics from the PostgreSQL `pg_stat_database` view, providing insights into the current database's performance.
      It returns the number of backends, transaction commits and rollbacks, buffer reads and hits, tuple statistics, conflicts, temporary files and bytes,
      deadlocks, block read and write times, postmaster uptime, backup duration, recovery status, system identifier, and invalid indexes.
      This metric helps administrators monitor database activity and performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
      12: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,
          checksum_failures,
          extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
      14: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,
          checksum_failures,
          extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          session_time::int8,
          active_time::int8,
          idle_in_transaction_time::int8,
          sessions,
          sessions_abandoned,
          sessions_fatal,
          sessions_killed,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
      15: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          checksum_failures,
          extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          session_time::int8,
          active_time::int8,
          idle_in_transaction_time::int8,
          sessions,
          sessions_abandoned,
          sessions_fatal,
          sessions_killed,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
    gauges:
      - numbackends
      - postmaster_uptime_s
      - backup_duration_s
      - backup_duration_s
      - checksum_last_failure_s
  locks_mode:
    description: >
      Retrieves lock mode statistics from the PostgreSQL `pg_locks` view, providing insights into the different lock modes currently held in the database.
      It returns the lock mode and the count of locks for each mode. This metric helps administrators monitor lock contention and performance.
    sqls:
      11: |-
        WITH q_locks AS (
          select
            *
          from
            pg_locks
          where
            pid != pg_backend_pid()
            and database = (select oid from pg_database where datname = current_database())
        )
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          lockmodes AS tag_lockmode,
          coalesce((select count(*) FROM q_locks WHERE mode = lockmodes), 0) AS count
        FROM
          unnest('{AccessShareLock, ExclusiveLock, RowShareLock, RowExclusiveLock, ShareLock, ShareRowExclusiveLock,  AccessExclusiveLock, ShareUpdateExclusiveLock}'::text[]) lockmodes
    gauges:
      - '*'
  replication:
    description: >
      This metric collects replication statistics from the `pg_stat_replication` view.
      It provides insights into the status of replication connections, including lag times and states.
      This metric is useful for monitoring replication health and performance.
    sqls:
      11: |
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          application_name as tag_application_name,
          usename AS tag_usename,
          concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, sent_lsn)::int8, 0) as sent_lag_b,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, write_lsn)::int8, 0) as write_lag_b,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, flush_lsn)::int8, 0) as flush_lag_b,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, replay_lsn)::int8, 0) as replay_lag_b,
          (extract(epoch from write_lag) * 1000)::int8 as write_lag_ms,
          (extract(epoch from flush_lag) * 1000)::int8 as flush_lag_ms,
          (extract(epoch from replay_lag) * 1000)::int8 as replay_lag_ms,
          state,
          sync_state,
          case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int
        from
          pg_stat_replication
        where
          coalesce(application_name, '') not in ('pg_basebackup', 'pg_rewind');
    gauges:
      - '*'
    is_instance_level: true
  replication_slots:
    description: >
      This metric collects information about replication slots from the `pg_replication_slots` view.
      It provides insights into the status of replication slots, including their activity and lag times.
      This metric is useful for monitoring replication slot health and performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          slot_name::text as tag_slot_name,
          coalesce(plugin, 'physical')::text as tag_plugin,
          active,
          case when active then 0 else 1 end as non_active_int,
          pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)::int8 as restart_lsn_lag_b,
          greatest(age(xmin), age(catalog_xmin))::int8 as xmin_age_tx
        from
          pg_replication_slots
    node_status: primary
    gauges:
      - '*'
    is_instance_level: true
  settings:
    description: >
      This metric collects various PostgreSQL server settings and configurations.
      It provides insights into the server's configuration, including version, memory settings, and other important parameters.
      This metric is useful for monitoring server settings and ensuring optimal performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
          name as tag_setting_name,
          setting as tag_setting_value,
          unit as tag_unit,
          category as tag_category,
          vartype as tag_vartype,
          case when setting ~ '^-?[0-9]+$' then setting::bigint else null end as numeric_value,
          case when source != 'default' then 0 else 1 end as is_default,
          1 as configured
        from pg_settings
    gauges:
      - '*'
    is_instance_level: true
  sproc_stats:
    description: >
      This metric collects statistics about user-defined functions (stored procedures) in the database.
      It provides insights into function usage, including call counts and execution times.
      This metric is useful for monitoring function performance and identifying potential bottlenecks.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          schemaname::text AS tag_schema,
          funcname::text  AS tag_function_name,
          quote_ident(schemaname)||'.'||quote_ident(funcname) as tag_function_full_name,
          p.oid::text as tag_oid, -- for overloaded funcs
          calls as sp_calls,
          self_time,
          total_time
        FROM
          pg_stat_user_functions f
          JOIN
          pg_proc p ON p.oid = f.funcid
        ORDER BY
          total_time DESC
        LIMIT
          300

  table_stats:
    description: >
      This metric collects statistics about user tables, including size, vacuum status, and transaction freeze age.
      It provides insights into the health and performance of tables in the database.
    sqls:
      11: |-
        with recursive
            q_root_part as (
                select c.oid,
                        c.relkind,
                        n.nspname root_schema,
                        c.relname root_relname
                from pg_class c
                          join pg_namespace n on n.oid = c.relnamespace
                where relkind in ('p', 'r')
                  and relpersistence != 't'
                  and not n.nspname like any (array[E'pg\\_%', 'information_schema', E'\\_timescaledb%'])
                  and not exists(select * from pg_inherits where inhrelid = c.oid)
                  and exists(select * from pg_inherits where inhparent = c.oid)
            ),
            q_parts (relid, relkind, level, root) as (
                select oid, relkind, 1, oid
                from q_root_part
                union all
                select inhrelid, c.relkind, level + 1, q.root
                from pg_inherits i
                          join q_parts q on inhparent = q.relid
                          join pg_class c on c.oid = i.inhrelid
            ),
            q_tstats as (
                select (extract(epoch from now()) * 1e9)::int8                                                  as epoch_ns,
                        current_database()                                                                       as tag_datname,
                        relid, -- not sent to final output
                        quote_ident(schemaname)                                                                  as tag_schema,
                        quote_ident(ut.relname)                                                                  as tag_table_name,
                        quote_ident(schemaname) || '.' || quote_ident(ut.relname)                                as tag_table_full_name,
                        pg_table_size(relid)                                                                     as table_size_b,
                        abs(greatest(ceil(log((pg_table_size(relid) + 1) / 10 ^ 6)), 0))::text                   as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                        pg_total_relation_size(relid)                                                            as total_relation_size_b,
                        case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,
                        (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8               as seconds_since_last_vacuum,
                        (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8             as seconds_since_last_analyze,
                        case when 'autovacuum_enabled=off' = ANY (c.reloptions) then 1 else 0 end                as no_autovacuum,
                        seq_scan,
                        seq_tup_read,
                        coalesce(idx_scan, 0) as idx_scan,
                        coalesce(idx_tup_fetch, 0) as idx_tup_fetch,
                        n_tup_ins,
                        n_tup_upd,
                        n_tup_del,
                        n_tup_hot_upd,
                        n_live_tup,
                        n_dead_tup,
                        vacuum_count,
                        autovacuum_count,
                        analyze_count,
                        autoanalyze_count,
                        case when c.relkind != 'p' then age(c.relfrozenxid) else 0 end as tx_freeze_age
                from pg_stat_user_tables ut
                          join
                      pg_class c on c.oid = ut.relid
                where
                  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait
                    not exists(select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock')
                  and c.relpersistence != 't' -- and temp tables
            )
        
        select /* pgwatch_generated */
            epoch_ns,
            tag_datname,
            tag_schema,
            tag_table_name,
            tag_table_full_name,
            0 as is_part_root,
            table_size_b,
            tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
            total_relation_size_b,
            toast_size_b,
            seconds_since_last_vacuum,
            seconds_since_last_analyze,
            no_autovacuum,
            seq_scan,
            seq_tup_read,
            idx_scan,
            idx_tup_fetch,
            n_tup_ins,
            n_tup_upd,
            n_tup_del,
            n_tup_hot_upd,
            n_live_tup,
            n_dead_tup,
            vacuum_count,
            autovacuum_count,
            analyze_count,
            autoanalyze_count,
            tx_freeze_age
        from q_tstats
        where not tag_schema like E'\\_timescaledb%'
        and not exists (select * from q_root_part where oid = q_tstats.relid)
        
        union all
        
        select * from (
            select
                epoch_ns,
                quote_ident(qr.root_schema) as tag_schema,
                quote_ident(qr.root_relname) as tag_table_name,
                quote_ident(qr.root_schema) || '.' || quote_ident(qr.root_relname) as tag_table_full_name,
                1 as is_part_root,
                sum(table_size_b)::int8 table_size_b,
                abs(greatest(ceil(log((sum(table_size_b) + 1) / 10 ^ 6)),
                      0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                sum(total_relation_size_b)::int8 total_relation_size_b,
                sum(toast_size_b)::int8 toast_size_b,
                min(seconds_since_last_vacuum)::int8 seconds_since_last_vacuum,
                min(seconds_since_last_analyze)::int8 seconds_since_last_analyze,
                sum(no_autovacuum)::int8 no_autovacuum,
                sum(seq_scan)::int8 seq_scan,
                sum(seq_tup_read)::int8 seq_tup_read,
                sum(idx_scan)::int8 idx_scan,
                sum(idx_tup_fetch)::int8 idx_tup_fetch,
                sum(n_tup_ins)::int8 n_tup_ins,
                sum(n_tup_upd)::int8 n_tup_upd,
                sum(n_tup_del)::int8 n_tup_del,
                sum(n_tup_hot_upd)::int8 n_tup_hot_upd,
                sum(n_live_tup)::int8 n_live_tup,
                sum(n_dead_tup)::int8 n_dead_tup,
                sum(vacuum_count)::int8 vacuum_count,
                sum(autovacuum_count)::int8 autovacuum_count,
                sum(analyze_count)::int8 analyze_count,
                sum(autoanalyze_count)::int8 autoanalyze_count,
                max(tx_freeze_age)::int8 tx_freeze_age
              from
                    q_tstats ts
                    join q_parts qp on qp.relid = ts.relid
                    join q_root_part qr on qr.oid = qp.root
              group by
                    1, 2, 3, 4, 5
        ) x
        order by table_size_b desc nulls last limit 300
      16: |-
        with recursive /* pgwatch_generated */
            q_root_part as (
                select c.oid,
                        c.relkind,
                        n.nspname root_schema,
                        c.relname root_relname
                from pg_class c
                          join pg_namespace n on n.oid = c.relnamespace
                where relkind in ('p', 'r')
                  and relpersistence != 't'
                  and not n.nspname like any (array[E'pg\\_%', 'information_schema', E'\\_timescaledb%'])
                  and not exists(select * from pg_inherits where inhrelid = c.oid)
                  and exists(select * from pg_inherits where inhparent = c.oid)
            ),
            q_parts (relid, relkind, level, root) as (
                select oid, relkind, 1, oid
                from q_root_part
                union all
                select inhrelid, c.relkind, level + 1, q.root
                from pg_inherits i
                          join q_parts q on inhparent = q.relid
                          join pg_class c on c.oid = i.inhrelid
            ),
            q_tstats as (
                select (extract(epoch from now()) * 1e9)::int8                                                  as epoch_ns,
                        relid, -- not sent to final output
                        quote_ident(schemaname)                                                                  as tag_schema,
                        quote_ident(ut.relname)                                                                  as tag_table_name,
                        quote_ident(schemaname) || '.' || quote_ident(ut.relname)                                as tag_table_full_name,
                        pg_table_size(relid)                                                                     as table_size_b,
                        abs(greatest(ceil(log((pg_table_size(relid) + 1) / 10 ^ 6)), 0))::text                   as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                        pg_total_relation_size(relid)                                                            as total_relation_size_b,
                        case when c.reltoastrelid != 0 then pg_total_relation_size(c.reltoastrelid) else 0::int8 end as toast_size_b,
                        (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8               as seconds_since_last_vacuum,
                        (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8             as seconds_since_last_analyze,
                        case when 'autovacuum_enabled=off' = ANY (c.reloptions) then 1 else 0 end                as no_autovacuum,
                        seq_scan,
                        seq_tup_read,
                        coalesce(idx_scan, 0) as idx_scan,
                        coalesce(idx_tup_fetch, 0) as idx_tup_fetch,
                        n_tup_ins,
                        n_tup_upd,
                        n_tup_del,
                        n_tup_hot_upd,
                        n_live_tup,
                        n_dead_tup,
                        vacuum_count,
                        autovacuum_count,
                        analyze_count,
                        autoanalyze_count,
                        case when c.relkind != 'p' then age(c.relfrozenxid) else 0 end as tx_freeze_age,
                        extract(epoch from now() - last_seq_scan)::int8 as last_seq_scan_s
                from pg_stat_user_tables ut
                    join pg_class c on c.oid = ut.relid
                    left join pg_class t on t.oid = c.reltoastrelid
                    left join pg_index ti on ti.indrelid = t.oid
                    left join pg_class tir on tir.oid = ti.indexrelid
                where
                  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait
                  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock')
                  and c.relpersistence != 't' -- and temp tables
                order by case when c.relkind = 'p' then 1e9::int else coalesce(c.relpages, 0) + coalesce(t.relpages, 0) + coalesce(tir.relpages, 0) end desc
                limit 1500 /* NB! When changing the bottom final LIMIT also adjust this limit. Should be at least 5x bigger as approx sizes depend a lot on vacuum frequency.
                            The general idea is to reduce filesystem "stat"-ing on tables that won't make it to final output anyways based on approximate size */
            )
        
        select /* pgwatch_generated */
            epoch_ns,
            tag_schema,
            tag_table_name,
            tag_table_full_name,
            0 as is_part_root,
            table_size_b,
            tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
            total_relation_size_b,
            toast_size_b,
            seconds_since_last_vacuum,
            seconds_since_last_analyze,
            no_autovacuum,
            seq_scan,
            seq_tup_read,
            idx_scan,
            idx_tup_fetch,
            n_tup_ins,
            n_tup_upd,
            n_tup_del,
            n_tup_hot_upd,
            n_live_tup,
            n_dead_tup,
            vacuum_count,
            autovacuum_count,
            analyze_count,
            autoanalyze_count,
            tx_freeze_age,
            last_seq_scan_s
        from q_tstats
        where not tag_schema like E'\\_timescaledb%'
        and not exists (select * from q_root_part where oid = q_tstats.relid)
        
        union all
        
        select * from (
            select
                epoch_ns,
                quote_ident(qr.root_schema) as tag_schema,
                quote_ident(qr.root_relname) as tag_table_name,
                quote_ident(qr.root_schema) || '.' || quote_ident(qr.root_relname) as tag_table_full_name,
                1 as is_part_root,
                sum(table_size_b)::int8 table_size_b,
                abs(greatest(ceil(log((sum(table_size_b) + 1) / 10 ^ 6)),
                      0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                sum(total_relation_size_b)::int8 total_relation_size_b,
                sum(toast_size_b)::int8 toast_size_b,
                min(seconds_since_last_vacuum)::int8 seconds_since_last_vacuum,
                min(seconds_since_last_analyze)::int8 seconds_since_last_analyze,
                sum(no_autovacuum)::int8 no_autovacuum,
                sum(seq_scan)::int8 seq_scan,
                sum(seq_tup_read)::int8 seq_tup_read,
                sum(idx_scan)::int8 idx_scan,
                sum(idx_tup_fetch)::int8 idx_tup_fetch,
                sum(n_tup_ins)::int8 n_tup_ins,
                sum(n_tup_upd)::int8 n_tup_upd,
                sum(n_tup_del)::int8 n_tup_del,
                sum(n_tup_hot_upd)::int8 n_tup_hot_upd,
                sum(n_live_tup)::int8 n_live_tup,
                sum(n_dead_tup)::int8 n_dead_tup,
                sum(vacuum_count)::int8 vacuum_count,
                sum(autovacuum_count)::int8 autovacuum_count,
                sum(analyze_count)::int8 analyze_count,
                sum(autoanalyze_count)::int8 autoanalyze_count,
                max(tx_freeze_age)::int8 tx_freeze_age,
                min(last_seq_scan_s)::int8 last_seq_scan_s
              from
                    q_tstats ts
                    join q_parts qp on qp.relid = ts.relid
                    join q_root_part qr on qr.oid = qp.root
              group by
                    1, 2, 3, 4
        ) x
        order by table_size_b desc nulls last limit 300
    gauges:
      - table_size_b
      - total_relation_size_b
      - toast_size_b
      - seconds_since_last_vacuum
      - seconds_since_last_analyze
      - n_live_tup
      - n_dead_tup
    statement_timeout_seconds: 300
  wal:
    description: >
      This metric collects information about the Write-Ahead Logging (WAL) system in PostgreSQL.
      It provides insights into WAL activity, including the current WAL location, replay lag, and other related metrics.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          case
            when pg_is_in_recovery() = false then
              pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8
            else
              pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8
            end as xlog_location_b,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          system_identifier::text as tag_sys_id,
          case
            when pg_is_in_recovery() = false then
              ('x'||substr(pg_walfile_name(pg_current_wal_lsn()), 1, 8))::bit(32)::int
            else
              (select min_recovery_end_timeline::int from pg_control_recovery())
            end as timeline
        from pg_control_system()
    gauges:
      - '*'
    is_instance_level: true
  wait_events:
    description: >
      This metric retrieves information about wait events for active sessions in the PostgreSQL database.
      It tracks the wait event types and counts of processes currently experiencing each wait event type,
      providing insights into potential bottlenecks and resource contention issues.
    sqls:
      11: |-
        SELECT datname as tag_datname, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        FROM pg_stat_activity
        WHERE state = 'active'
        GROUP BY tag_datname, tag_wait_event_type, tag_wait_event
        UNION
        SELECT 'server_process' as tag_datname, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        FROM pg_stat_activity
        WHERE state = 'active' AND datname IS NULL 
        GROUP BY tag_datname, tag_wait_event_type, tag_wait_event
      14: |-
        SELECT datname as tag_datname, query_id::text as tag_query_id, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        FROM pg_stat_activity
        WHERE state = 'active'
        GROUP BY tag_datname, tag_query_id, tag_wait_event_type, tag_wait_event
        UNION
        SELECT 'server_process' as tag_datname, NULL as tag_query_id, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        FROM pg_stat_activity
        WHERE state = 'active' AND datname IS NULL 
        GROUP BY tag_datname, tag_query_id, tag_wait_event_type, tag_wait_event
    gauges:
      - total
    is_instance_level: true
  pg_stat_activity:
    sqls:
      11: |-
        SELECT /* pgwatch_generated */
            pg_database.datname AS tag_datname,
            tmp2.tag_application_name,
            tmp.tag_state,
            COALESCE(count,0) as count,
            COALESCE(max_tx_duration,0) as max_tx_duration
        FROM
          (
            VALUES ('active'),
                  ('idle'),
                  ('idle in transaction'),
                  ('idle in transaction (aborted)'),
                  ('fastpath function call'),
                  ('disabled')
          ) AS tmp(tag_state)
        CROSS JOIN pg_database
        LEFT JOIN
          (
            SELECT datname,
              application_name as tag_application_name,
              state as tag_state,
              count(*) AS count,
              MAX(EXTRACT(EPOCH FROM now() - xact_start))::float AS max_tx_duration
            FROM pg_stat_activity        GROUP BY datname, tag_application_name, tag_state
          ) AS tmp2
        ON tmp.tag_state = tmp2.tag_state AND pg_database.datname = tmp2.datname
        WHERE pg_database.datname = current_database()

    gauges:
      - count
      - max_tx_duration
  pg_archiver:
    sqls:
      11: |
        WITH
          current_wal_file AS (
            SELECT CASE WHEN NOT pg_is_in_recovery() THEN pg_walfile_name(pg_current_wal_insert_lsn()) ELSE NULL END pg_walfile_name
          ),
          current_wal AS (
            SELECT
              ('x'||substring(pg_walfile_name,9,8))::bit(32)::int log,
              ('x'||substring(pg_walfile_name,17,8))::bit(32)::int seg,
              pg_walfile_name
            FROM current_wal_file
          ),
          archive_wal AS(
            SELECT
              ('x'||substring(last_archived_wal,9,8))::bit(32)::int log,
              ('x'||substring(last_archived_wal,17,8))::bit(32)::int seg,
              last_archived_wal
            FROM pg_stat_archiver
          )
        SELECT current_database() as tag_datname, coalesce(((cw.log - aw.log) * 256) + (cw.seg-aw.seg), -1) as pending_wal_count FROM current_wal cw, archive_wal aw
    gauges:
      - pending_wal_count
  pg_blocked:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          count(blocked.transactionid) AS queries,
          '__transaction__' AS tag_table
        FROM pg_catalog.pg_locks blocked
        WHERE NOT blocked.granted AND locktype = 'transactionid'
        GROUP BY locktype
        UNION
        SELECT
          count(blocked.relation) AS queries,
          blocked.relation::regclass::text AS tag_table
        FROM pg_catalog.pg_locks blocked
        WHERE NOT blocked.granted AND locktype != 'transactionid'
        GROUP BY relation
    gauges:
      - queries
  pg_database_wraparound:
    sqls:
      11: |
        SELECT
          datname as tag_datname,
          age(d.datfrozenxid) as age_datfrozenxid,
          mxid_age(d.datminmxid) as age_datminmxid
        FROM
          pg_catalog.pg_database d
        WHERE
          d.datallowconn
    gauges:
      - age_datfrozenxid
      - age_datminmxid
  pg_gin_index:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          index_name AS tag_index_name,
          pending_list_bytes AS pending_list_bytes
        FROM
          postgres_gin_pending_list_size()
    gauges:
      - pending_list_bytes
  pg_indexes_with_size:
    sqls:
      11: SELECT current_database() as tag_datname, schemaname as tag_schemaname, tablename as tag_relname, indexname as tag_indexrelname, pg_class.relpages
        * 8192::bigint as index_size from pg_indexes inner join pg_namespace on pg_indexes.schemaname
        = pg_namespace.nspname inner join pg_class on pg_class.relnamespace = pg_namespace.oid
        and pg_class.relname = pg_indexes.indexname where pg_indexes.schemaname != 'pg_catalog' and pg_indexes.schemaname != 'pg_toast'
    gauges:
      - index_size
  pg_integer_capacity:
    sqls:
      11: |
        SELECT current_database() as tag_datname, 'sent_notifications' as tag_table_name, 'id' as tag_column_name, max(id) as current, (select (2^(numeric_precision-1)-1) as maximum FROM information_schema.columns WHERE (table_name, column_name) = ('sent_notifications', 'id')) FROM sent_notifications
          UNION ALL
                  SELECT current_database() as tag_datname, 'notes', 'id', max(id), (select (2^(numeric_precision-1)-1) FROM information_schema.columns WHERE (table_name, column_name) = ('notes', 'id')) FROM notes
          UNION ALL
                  SELECT current_database() as tag_datname, 'system_note_metadata', 'id', max(id), (select (2^(numeric_precision-1)-1) FROM information_schema.columns WHERE (table_name, column_name) = ('system_note_metadata', 'id')) FROM system_note_metadata
          UNION ALL
        SELECT current_database() as tag_datname, 'merge_request_diffs', 'id', max(id), (select (2^(numeric_precision-1)-1) FROM information_schema.columns WHERE (table_name, column_name) = ('merge_request_diffs', 'id')) FROM merge_request_diffs
          UNION ALL
        SELECT current_database() as tag_datname, 'merge_request_metrics', 'id', max(id), (select (2^(numeric_precision-1)-1) FROM information_schema.columns WHERE (table_name, column_name) = ('merge_request_metrics', 'id')) FROM merge_request_metrics
          UNION ALL
        SELECT current_database() as tag_datname, 'deployments', 'id', max(id), (select (2^(numeric_precision-1)-1) FROM information_schema.columns WHERE (table_name, column_name) = ('deployments', 'id')) FROM deployments
    gauges:
      - current
      - maximum
  pg_long_running_transactions:
    sqls:
      11: |
        SELECT current_database() as tag_datname,
        COUNT(*) as transactions,
        COALESCE(MAX(EXTRACT(EPOCH FROM (clock_timestamp() - xact_start)))::int8, 0) AS age_in_seconds
        FROM pg_catalog.pg_stat_activity
        WHERE state is distinct from 'idle' AND (now() - xact_start) > '1 minutes'::interval AND query not like 'autovacuum:%'
    gauges:
      - '*'
  pg_oldest_blocked:
    sqls:
      11: |
        SELECT current_database() as tag_datname,
        coalesce(extract('epoch' from max(clock_timestamp() - state_change)), 0) age_seconds
          FROM pg_catalog.pg_stat_activity
        WHERE wait_event_type = 'Lock'
          AND state='active'
    gauges:
      - age_seconds
  pg_postmaster:
    sqls:
      11: SELECT current_database() as tag_datname, pg_postmaster_start_time as start_time_seconds from pg_postmaster_start_time()
    gauges:
      - start_time_seconds
  pg_replication:
    sqls:
      11: SELECT current_database() as tag_datname, CASE WHEN NOT pg_is_in_recovery() THEN 0 ELSE GREATEST (0, EXTRACT(EPOCH
        FROM (now() - pg_last_xact_replay_timestamp()))) END AS lag, CASE WHEN pg_is_in_recovery()
        THEN 1 ELSE 0 END as is_replica
    gauges:
      - lag
      - is_replica
  pg_replication_slots:
    sqls:
      11: |
        SELECT current_database() as tag_datname, slot_name as tag_slot_name, slot_type as tag_slot_type,
              case when active then 1.0 else 0.0 end AS active,
              age(xmin) AS xmin_age,
              age(catalog_xmin) AS catalog_xmin_age,
              CASE WHEN pg_is_in_recovery() THEN pg_last_wal_replay_lsn() ELSE pg_current_wal_lsn() END - restart_lsn AS restart_lsn_bytes,
              CASE WHEN pg_is_in_recovery() THEN pg_last_wal_replay_lsn() ELSE pg_current_wal_lsn() END - confirmed_flush_lsn AS confirmed_flush_lsn_bytes
          FROM pg_replication_slots
    gauges:
      - active
      - xmin_age
      - catalog_xmin_age
      - restart_lsn_bytes
      - confirmed_flush_lsn_bytes
  pg_slow:
    sqls:
      11: |
        SELECT current_database() as tag_datname, COUNT(*) AS queries
        FROM pg_catalog.pg_stat_activity
        WHERE state = 'active' AND (now() - query_start) > '1 seconds'::interval
    gauges:
      - queries
  pg_stat_activity_autovacuum:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          SPLIT_PART(query, '.', 2) AS tag_relname,
          EXTRACT(EPOCH FROM (clock_timestamp() - xact_start)) AS tag_age_in_seconds
        FROM
          pg_catalog.pg_stat_activity
        WHERE
          query like 'autovacuum:%'
        AND
          EXTRACT(EPOCH FROM (clock_timestamp() - xact_start)) > 300
    gauges:
      - age_in_seconds
  pg_stat_activity_autovacuum_active:
    sqls:
      11: |
        SELECT current_database() as tag_datname,
        v.phase as tag_phase,
              CASE
                when a.query ~ '^autovacuum.*to prevent wraparound' then 'wraparound'
                when a.query ~* '^vacuum' then 'user'
                when a.pid is null then null
                ELSE 'regular'
              END as tag_mode,
              count(1) as workers_count
          FROM pg_stat_progress_vacuum v
          LEFT JOIN pg_catalog.pg_stat_activity a using (pid)
        GROUP BY 1,2
    gauges:
      - workers_count
  pg_stat_kcache:
    sqls:
      11: "WITH ranked_kcache AS (\n   SELECT pg_get_userbyid(pg_stat_kcache_raw.userid)\
        \ AS tag_user,\n     pg_database.datname,\n     pg_stat_kcache_raw.queryid,\n  \
        \   pg_stat_kcache_raw.exec_user_time,\n     pg_stat_kcache_raw.exec_system_time,\n\
        \     pg_stat_kcache_raw.exec_user_time + pg_stat_kcache_raw.exec_system_time\
        \ AS tag_exec_total_time,\n     row_number() over (order by pg_stat_kcache_raw.exec_user_time\
        \ + pg_stat_kcache_raw.exec_system_time desc) as rn\n   FROM public.pg_stat_kcache()\
        \ pg_stat_kcache_raw\n     INNER JOIN pg_database ON pg_database.oid = pg_stat_kcache_raw.dbid\n\
        )    \nSELECT\n  ranked_kcache.tag_user,\n  datname,\n  queryid,\n  exec_user_time,\n\
        \  exec_system_time,\n  exec_total_time\nFROM ranked_kcache\nWHERE rn <= 500\n\
        UNION ALL\nSELECT\n  'tail_dummy_user' as tag_user,\n  current_database() as datname,\n\
        \  -1 as queryid,\n  sum(exec_user_time) as exec_user_time,\n  sum(exec_system_time)\
        \ as exec_system_time,\n  sum(exec_total_time) as exec_total_time\nFROM ranked_kcache\n\
        WHERE rn > 500\n"
    gauges:
      - exec_user_time
      - exec_system_time
      - exec_total_time
  pg_stat_replication:
    sqls:
      11: "SELECT current_database() as tag_datname,\n  application_name as tag_application_name, \n  (pg_current_wal_lsn() - '0/0') % (2^52)::bigint\
        \ as current_wal_lsn, \n  (sent_lsn - '0/0') % (2^52)::bigint as sent_lsn, \n\
        \  (write_lsn - '0/0') % (2^52)::bigint as write_lsn, \n  (flush_lsn - '0/0')\
        \ % (2^52)::bigint as flush_lsn, \n  (replay_lsn - '0/0') % (2^52)::bigint as\
        \ replay_lsn,\n  EXTRACT(SECONDS FROM (now() - reply_time)) reply_time_lag \n\
        \ FROM pg_stat_replication\n"
    gauges:
      - current_wal_lsn
      - sent_lsn
      - write_lsn
      - flush_lsn
      - replay_lsn
      - reply_time_lag
  pg_stat_ssl:
    sqls:
      11: |
        SELECT current_database() as tag_datname, pid as tag_pid, bits as bits,
              CASE WHEN ssl THEN 1.0 ELSE 0.0 END AS active
              FROM pg_stat_ssl
    gauges:
      - active
      - bits
  pg_stat_statements:
    sqls:
      11: |
        WITH ranked_statements AS (
          SELECT
            pg_get_userbyid(userid) as user,
            pg_database.datname,
            pg_stat_statements.queryid ,
            pg_stat_statements.plans as plans_total,
            pg_stat_statements.calls,
            pg_stat_statements.total_exec_time as exec_time_total,
            pg_stat_statements.total_plan_time as plan_time_total,
            pg_stat_statements.rows,
            (current_setting('block_size')::int * pg_stat_statements.shared_blks_hit) as shared_bytes_hit_total,
            (current_setting('block_size')::int * pg_stat_statements.shared_blks_read) as shared_bytes_read_total,
            (current_setting('block_size')::int * pg_stat_statements.shared_blks_dirtied) as shared_bytes_dirtied_total,
            (current_setting('block_size')::int * pg_stat_statements.shared_blks_written) as shared_bytes_written_total,
            pg_stat_statements.blk_read_time as block_read_total,
            pg_stat_statements.blk_write_time as block_write_total,
            pg_stat_statements.wal_records,
            pg_stat_statements.wal_fpi,
            pg_stat_statements.wal_bytes,
            (current_setting('block_size')::int * pg_stat_statements.temp_blks_read) as temp_bytes_read,
            (current_setting('block_size')::int * pg_stat_statements.temp_blks_written) as temp_bytes_written,
            row_number() over (order by total_exec_time desc) as rn
            FROM pg_stat_statements
            JOIN pg_database
            ON pg_database.oid = pg_stat_statements.dbid
        )
        SELECT
          ranked_statements.user as tag_user,
          datname as tag_datname,
          queryid as tag_queryid,
          calls::int8 as calls,
          plans_total::int8 as plans_total,
          exec_time_total::int8 as exec_time_total,
          plan_time_total::int8 as plan_time_total,
          rows::int8 as rows,
          shared_bytes_hit_total::int8 as shared_bytes_hit_total,
          shared_bytes_read_total::int8 as shared_bytes_read_total,
          shared_bytes_dirtied_total::int8 as shared_bytes_dirtied_total,
          shared_bytes_written_total::int8 as shared_bytes_written_total,
          block_read_total::int8 as block_read_total,
          block_write_total::int8 as block_write_total,
          wal_records::int8 as wal_records,
          wal_fpi::int8 as wal_fpi,
          wal_bytes::int8 as wal_bytes,
          temp_bytes_read::int8 as temp_bytes_read,
          temp_bytes_written::int8 as temp_bytes_written
          FROM ranked_statements
          WHERE rn <= 500
        UNION ALL
        SELECT
          'tail_dummy_user' as tag_user,
          current_database() as tag_datname,
          -1 as tag_qqueryid,
          sum(calls)::int8 as calls,
          sum(plans_total)::int8 as plans_total,
          sum(exec_time_total)::int8 as exec_time_total,
          sum(plan_time_total)::int8 as plan_time_total,
          sum(rows)::int8 as rows,
          sum(shared_bytes_hit_total)::int8 as shared_bytes_hit_total,
          sum(shared_bytes_read_total)::int8 as shared_bytes_read_total,
          sum(shared_bytes_dirtied_total)::int8 as shared_bytes_dirtied_total,
          sum(shared_bytes_written_total)::int8 as shared_bytes_written_total,
          sum(block_read_total)::int8 as block_read_total,
          sum(block_write_total)::int8 as block_write_total,
          sum(wal_records)::int8 as wal_records,
          sum(wal_fpi)::int8 as wal_fpi,
          sum(wal_bytes)::int8 as wal_bytes,
          sum(temp_bytes_read)::int8 as temp_bytes_read,
          sum(temp_bytes_written)::int8 as temp_bytes_written
        FROM ranked_statements
        WHERE rn > 500
    gauges:
      - calls
      - plans_total
      - exec_time_total
      - plan_time_total
      - rows
      - shared_bytes_hit_total
      - shared_bytes_read_total
      - shared_bytes_dirtied_total
      - shared_bytes_written_total
      - block_read_total
      - block_write_total
      - wal_records
      - wal_fpi
      - wal_bytes
      - temp_bytes_read
      - temp_bytes_written
  pg_stat_user_indexes:
    sqls:
      11: SELECT schemaname as tag_schemaname, relname as tag_relname, indexrelname as tag_indexrelname, idx_scan, idx_tup_read, idx_tup_fetch
        FROM pg_stat_user_indexes
    gauges:
      - idx_scan
      - idx_tup_read
      - idx_tup_fetch
  pg_stat_user_tables:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          schemaname as tag_schemaname,
          relname as tag_relname,
          seq_scan,
          seq_tup_read,
          idx_scan,
          idx_tup_fetch,
          n_tup_ins,
          n_tup_upd,
          n_tup_del,
          n_tup_hot_upd,
          n_live_tup,
          n_dead_tup,
          GREATEST(last_autovacuum, last_vacuum, '1970-01-01Z') as last_vacuum,
          GREATEST(last_autoanalyze, last_analyze, '1970-01-01Z') as last_analyze,
          (vacuum_count + autovacuum_count) as vacuum_count,
          (analyze_count + autoanalyze_count) as analyze_count
        FROM
          pg_stat_user_tables
    gauges:
      - seq_scan
      - seq_tup_read
      - idx_scan
      - idx_tup_fetch
      - n_tup_ins
      - n_tup_upd
      - n_tup_del
      - n_tup_hot_upd
      - n_live_tup
      - n_dead_tup
      - last_vacuum
      - last_analyze
      - vacuum_count
      - analyze_count
  pg_stat_wal_receiver:
    sqls:
      11: |
        SELECT current_database() as tag_datname,
        case status when 'stopped' then 0 when 'starting' then 1 when 'streaming' then 2 when 'waiting' then 3 when 'restarting' then 4 when 'stopping' then 5 else -1 end as tag_status,
              (receive_start_lsn- '0/0') % (2^52)::bigint as receive_start_lsn,
              receive_start_tli,
              (flushed_lsn- '0/0') % (2^52)::bigint as flushed_lsn,
              received_tli,
              extract(epoch from last_msg_send_time) as last_msg_send_time,
              extract(epoch from last_msg_receipt_time) as last_msg_receipt_time,
              (latest_end_lsn - '0/0') % (2^52)::bigint as latest_end_lsn,
              extract(epoch from latest_end_time) as latest_end_time,
              substring(slot_name from 'repmgr_slot_([0-9]*)') as upstream_node,
              trim(both '''' from substring(conninfo from 'host=([^ ]*)')) as tag_upstream_host,
              slot_name
          FROM pg_catalog.pg_stat_wal_receiver
    gauges:
      - status
      - receive_start_lsn
      - receive_start_tli
      - flushed_lsn
      - received_tli
      - last_msg_send_time
      - last_msg_receipt_time
      - latest_end_lsn
      - latest_end_time
      - upstream_node
  pg_statio_user_indexes:
    sqls:
      11: SELECT current_database() as tag_datname, schemaname as tag_schemaname, relname as tag_relname, indexrelname as tag_indexrelname, idx_blks_read, idx_blks_hit FROM
        pg_statio_user_indexes
    gauges:
      - idx_blks_read
      - idx_blks_hit
  pg_statio_user_tables:
    sqls:
      11: SELECT current_database() as tag_datname, schemaname as tag_schemaname, relname as tag_relname, heap_blks_read, heap_blks_hit, idx_blks_read,
        idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read, tidx_blks_hit
        FROM pg_statio_user_tables
    gauges:
      - heap_blks_read
      - heap_blks_hit
      - idx_blks_read
      - idx_blks_hit
      - toast_blks_read
      - toast_blks_hit
      - tidx_blks_read
      - tidx_blks_hit
  pg_stuck_idle_in_transaction:
    sqls:
      11: |
        SELECT current_database() as tag_datname, COUNT(*) AS queries
        FROM pg_catalog.pg_stat_activity
        WHERE state = 'idle in transaction' AND (now() - query_start) > '10 minutes'::interval
    gauges:
      - queries
  pg_total_relation_size:
    sqls:
      11: |
        SELECT current_database() as tag_datname,
        relnamespace::regnamespace as tag_schemaname,
              relname as tag_relname,
              pg_total_relation_size(oid) bytes
          FROM pg_class
        WHERE relkind = 'r';
    gauges:
      - bytes
  pg_txid:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() % (2^52)::bigint END AS current,
          CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_snapshot_xmin(txid_current_snapshot()) % (2^52)::bigint END AS xmin,
          CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() - txid_snapshot_xmin(txid_current_snapshot()) END AS xmin_age
    gauges:
      - current
      - xmin
      - xmin_age
  pg_wait_sampling:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          coalesce(p.event_type, 'CPU*') as tag_wait_type,
          coalesce(p.event, 'CPU*') as tag_wait_event,
          SUM(p.count) as count,
          p.queryid as tag_queryid,
          pgsa.backend_type as tag_backend_type
        FROM pg_wait_sampling_profile p LEFT OUTER JOIN pg_stat_statements s on p.queryid = s.queryid LEFT OUTER JOIN pg_stat_activity pgsa on pgsa.pid = p.pid GROUP BY p.queryid, p.event_type, p.event, pgsa.backend_type
    gauges:
      - count
  pg_wait_sampling_agg:
    sqls:
      11: |
        SELECT
          current_database() as tag_datname,
          coalesce(p.event_type, 'CPU*') as tag_wait_type,
          coalesce(p.event, 'CPU*') as tag_wait_event,
          SUM(p.count) as count
        FROM pg_wait_sampling_profile p GROUP BY p.event_type, p.event
    gauges:
      - count
  pg_xlog_position:
    sqls:
      11: |
        SELECT current_database() as tag_datname,
        CASE
              WHEN pg_is_in_recovery()
              THEN (pg_last_wal_replay_lsn() - '0/0') % (2^52)::bigint
              ELSE (pg_current_wal_lsn() - '0/0') % (2^52)::bigint
              END AS bytes
    gauges:
      - bytes



presets:
  full:
    description: almost all available metrics for a even deeper performance understanding
    metrics:
      backends: 5
      bgwriter: 5
      checkpointer: 5
      db_size: 5
      db_stats: 5
      locks_mode: 5
      replication: 5
      replication_slots: 5
      settings: 5
      sproc_stats: 5
      table_io_stats: 5
      table_stats: 5
      wait_events: 5
      wal: 5
      pg_stat_activity: 5
      pg_replication: 5
      pg_stat_wal_receiver: 5
      pg_archiver: 5
      pg_postmaster: 5
      pg_stat_user_tables: 5
      pg_statio_user_tables: 5
      pg_stat_user_indexes: 5
      pg_statio_user_indexes: 5
      pg_indexes_with_size: 5
      pg_stat_statements: 5
      pg_stat_kcache: 5
      pg_total_relation_size: 5
      pg_blocked: 5
      pg_oldest_blocked: 5
      pg_slow: 5
      pg_long_running_transactions: 5
      pg_stuck_idle_in_transaction: 5
      pg_txid: 5
      pg_database_wraparound: 5
      pg_xlog_position: 5
      pg_replication_slots: 5
      pg_stat_ssl: 5
      pg_integer_capacity: 5
      pg_wait_sampling: 5
      pg_wait_sampling_agg: 5
      pg_stat_activity_autovacuum: 5
      pg_stat_activity_autovacuum_active: 5
      pg_gin_index: 5
