# Simple PGWatch Metrics for Prometheus - just queryid and calls

# The following structure is expected for metrics and preset definitions:
# metrics:
#    metric_name:
#        init_sql: |-
#            CREATE EXTENSIon IF not EXISTS some_extension;
#            CREATE OR REPLACE FUNCTIon get_some_stat(OUT some_stat int)
#            ...
#        sqls:
#            11: |
#                select /* pgwatch_generated */
#                  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
#                  ...
#            14: |
#                select /* pgwatch_generated */
#                  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
#                  ...
#        gauges:
#            - '*'
#        is_instance_level: true
#        node_status: primary
#        statement_timeout_seconds: 300
#        metric_storage_name: db_stats
metrics:
  bgwriter:
    description: >
      Retrieves key statistics from the PostgreSQL `pg_stat_bgwriter` view, providing insights into the background writer's performance.
      It returns the number of timed and requested checkpoints, checkpoint write and sync times, buffer statistics, and the last reset time.
      This metric helps administrators monitor the background writer's activity and its impact on database performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
            (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
            current_database() as tag_datname,
            checkpoints_timed,
            checkpoints_req,
            checkpoint_write_time,
            checkpoint_sync_time,
            buffers_checkpoint,
            buffers_clean,
            maxwritten_clean,
            buffers_backend,
            buffers_backend_fsync,
            buffers_alloc
          from
            pg_stat_bgwriter
      17: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          buffers_clean,
          maxwritten_clean,
          buffers_alloc,
          (extract(epoch from now() - stats_reset))::int as last_reset_s
        from
          pg_stat_bgwriter
    node_status: primary
    is_instance_level: true
    statement_timeout_seconds: 15
  checkpointer:
    description: >
      Retrieves key statistics from the PostgreSQL `pg_stat_checkpointer` view, providing insights into the checkpointer's performance.
      It returns the number of timed and requested checkpoints, restart points, write and sync times, and buffer statistics.
      This metric helps administrators monitor the checkpointer's activity and its impact on database performance.
    sqls:
      11: "; -- covered by bgwriter"
      17: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          num_timed,
          num_requested,
          restartpoints_timed,
          restartpoints_req,
          restartpoints_done,
          write_time,
          sync_time,
          buffers_written,
          (extract(epoch from now() - stats_reset))::int as last_reset_s
        from
          pg_stat_checkpointer
    statement_timeout_seconds: 15
  db_size:
    description: >
      Retrieves the size of the current database and the size of the `pg_catalog` schema, providing insights into the storage usage of the database.
      It returns the size in bytes for both the current database and the catalog schema.
      This metric helps administrators monitor database size and storage consumption.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          pg_database_size(current_database()) as size_b,
          (select sum(pg_total_relation_size(c.oid))::int8
            from pg_class c join pg_namespace n on n.oid = c.relnamespace
            where nspname = 'pg_catalog' and relkind = 'r'
          ) as catalog_size_b
    gauges:
      - '*'
    statement_timeout_seconds: 300
  db_stats:
    description: >
      Retrieves key statistics from the PostgreSQL `pg_stat_database` view, providing insights into the current database's performance.
      It returns the number of backends, transaction commits and rollbacks, buffer reads and hits, tuple statistics, conflicts, temporary files and bytes,
      deadlocks, block read and write times, postmaster uptime, backup duration, recovery status, system identifier, and invalid indexes.
      This metric helps administrators monitor database activity and performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
      12: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,
          checksum_failures,
          extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
      14: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,
          checksum_failures,
          extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          session_time::int8,
          active_time::int8,
          idle_in_transaction_time::int8,
          sessions,
          sessions_abandoned,
          sessions_fatal,
          sessions_killed,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
      15: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          numbackends,
          xact_commit,
          xact_rollback,
          blks_read,
          blks_hit,
          tup_returned,
          tup_fetched,
          tup_inserted,
          tup_updated,
          tup_deleted,
          conflicts,
          temp_files,
          temp_bytes,
          deadlocks,
          blk_read_time,
          blk_write_time,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          checksum_failures,
          extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          system_identifier::text as tag_sys_id,
          session_time::int8,
          active_time::int8,
          idle_in_transaction_time::int8,
          sessions,
          sessions_abandoned,
          sessions_fatal,
          sessions_killed,
          (select count(*) from pg_index i
            where not indisvalid
            and not exists ( /* leave out ones that are being actively rebuilt */
              select * from pg_locks l
              join pg_stat_activity a using (pid)
              where l.relation = i.indexrelid
              and a.state = 'active'
              and a.query ~* 'concurrently'
          )) as invalid_indexes
        from
          pg_stat_database, pg_control_system()
        where
          datname = current_database()
    gauges:
      - '*'
    statement_timeout_seconds: 15
  locks_mode:
    description: >
      Retrieves lock mode statistics from the PostgreSQL `pg_locks` view, providing insights into the different lock modes currently held in the database.
      It returns the lock mode and the count of locks for each mode. This metric helps administrators monitor lock contention and performance.
    sqls:
      13: |-
        WITH q_locks as (
          select
            *
          from
            pg_locks
          where
            pid <> pg_backend_pid()
            and database = (select oid from pg_database where datname = current_database())
          limit 5000
        )
        
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          lockmodes as tag_lockmode,
          coalesce((select count(*) from q_locks where mode = lockmodes), 0) as count
        from
          unnest('{AccessShareLock, ExclusiveLock, RowShareLock, RowExclusiveLock, ShareLock, ShareRowExclusiveLock,  AccessExclusiveLock, ShareUpdateExclusiveLock}'::text[]) lockmodes
    gauges:
      - '*'
    statement_timeout_seconds: 15
  replication:
    description: >
      This metric collects replication statistics from the `pg_stat_replication` view.
      It provides insights into the status of replication connections, including lag times and states.
      This metric is useful for monitoring replication health and performance.
    sqls:
      11: |
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          application_name as tag_application_name,
          usename as tag_usename,
          concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, sent_lsn)::int8, 0) as sent_lag_b,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, write_lsn)::int8, 0) as write_lag_b,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, flush_lsn)::int8, 0) as flush_lag_b,
          coalesce(pg_wal_lsn_diff(case when pg_is_in_recovery() then pg_last_wal_receive_lsn() else pg_current_wal_lsn() end, replay_lsn)::int8, 0) as replay_lag_b,
          (extract(epoch from write_lag) * 1000)::int8 as write_lag_ms,
          (extract(epoch from flush_lag) * 1000)::int8 as flush_lag_ms,
          (extract(epoch from replay_lag) * 1000)::int8 as replay_lag_ms,
          state,
          sync_state,
          case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int
        from
          pg_stat_replication
        where
          coalesce(application_name, '') not in ('pg_basebackup', 'pg_rewind');
    gauges:
      - '*'
    is_instance_level: true
    statement_timeout_seconds: 15
  replication_slots:
    description: >
      This metric collects information about replication slots from the `pg_replication_slots` view.
      It provides insights into the status of replication slots, including their activity and lag times.
      This metric is useful for monitoring replication slot health and performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          slot_name::text as tag_slot_name,
          coalesce(plugin, 'physical')::text as tag_plugin,
          active,
          case when active then 0 else 1 end as non_active_int,
          pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)::int8 as restart_lsn_lag_b,
          greatest(age(xmin), age(catalog_xmin))::int8 as xmin_age_tx
        from
          pg_replication_slots
    node_status: primary
    gauges:
      - '*'
    is_instance_level: true
    statement_timeout_seconds: 15
  settings:
    description: >
      This metric collects various PostgreSQL server settings and configurations.
      It provides insights into the server's configuration, including version, memory settings, and other important parameters.
      This metric is useful for monitoring server settings and ensuring optimal performance.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          name as tag_setting_name,
          setting as tag_setting_value,
          unit as tag_unit,
          category as tag_category,
          vartype as tag_vartype,
          case when setting ~ '^-?[0-9]+$' then setting::bigint else null end as numeric_value,
          case when source <> 'default' then 0 else 1 end as is_default,
          1 as configured
        from pg_settings
    gauges:
      - '*'
    is_instance_level: true
    statement_timeout_seconds: 15

  table_stats:
    description: >
      This metric collects statistics about user tables, including size, vacuum status, and transaction freeze age.
      It provides insights into the health and performance of tables in the database.
    sqls:
      11: |-
        with recursive
            q_root_part as (
                select c.oid,
                        c.relkind,
                        n.nspname root_schema,
                        c.relname root_relname
                from pg_class c
                          join pg_namespace n on n.oid = c.relnamespace
                where relkind in ('p', 'r')
                  and relpersistence <> 't'
                  and not n.nspname like any (array[E'pg\\_%', 'information_schema', E'\\_timescaledb%'])
                  and not exists(select * from pg_inherits where inhrelid = c.oid)
                  and exists(select * from pg_inherits where inhparent = c.oid)
            ),
            q_parts (relid, relkind, level, root) as (
                select oid, relkind, 1, oid
                from q_root_part
                union all
                select inhrelid, c.relkind, level + 1, q.root
                from pg_inherits i
                          join q_parts q on inhparent = q.relid
                          join pg_class c on c.oid = i.inhrelid
            ),
            q_tstats as (
                select (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
                        current_database()                                                                       as tag_datname,
                        relid, -- not sent to final output
                        quote_ident(schemaname)                                                                  as tag_schema,
                        quote_ident(ut.relname)                                                                  as tag_table_name,
                        quote_ident(schemaname) || '.' || quote_ident(ut.relname)                                as tag_table_full_name,
                        pg_table_size(relid)                                                                     as table_size_b,
                        abs(greatest(ceil(log((pg_table_size(relid) + 1) / 10 ^ 6)), 0))::text                   as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                        pg_total_relation_size(relid)                                                            as total_relation_size_b,
                        case when reltoastrelid <> 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,
                        (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8               as seconds_since_last_vacuum,
                        (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8             as seconds_since_last_analyze,
                        case when 'autovacuum_enabled=off' = ANY (c.reloptions) then 1 else 0 end                as no_autovacuum,
                        seq_scan,
                        seq_tup_read,
                        coalesce(idx_scan, 0) as idx_scan,
                        coalesce(idx_tup_fetch, 0) as idx_tup_fetch,
                        n_tup_ins,
                        n_tup_upd,
                        n_tup_del,
                        n_tup_hot_upd,
                        n_live_tup,
                        n_dead_tup,
                        vacuum_count,
                        autovacuum_count,
                        analyze_count,
                        autoanalyze_count,
                        case when c.relkind <> 'p' then age(c.relfrozenxid) else 0 end as tx_freeze_age
                from pg_stat_all_tables ut
                          join
                      pg_class c on c.oid = ut.relid
                where
                  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait
                    not exists(select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock')
                  and c.relpersistence <> 't' -- and temp tables
            )
        
        select /* pgwatch_generated */
            epoch_ns,
            tag_datname,
            tag_schema,
            tag_table_name,
            tag_table_full_name,
            0 as is_part_root,
            table_size_b,
            tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
            total_relation_size_b,
            toast_size_b,
            seconds_since_last_vacuum,
            seconds_since_last_analyze,
            no_autovacuum,
            seq_scan,
            seq_tup_read,
            idx_scan,
            idx_tup_fetch,
            n_tup_ins,
            n_tup_upd,
            n_tup_del,
            n_tup_hot_upd,
            n_live_tup,
            n_dead_tup,
            vacuum_count,
            autovacuum_count,
            analyze_count,
            autoanalyze_count,
            tx_freeze_age
        from q_tstats
        where not tag_schema like E'\\_timescaledb%'
        and not exists (select * from q_root_part where oid = q_tstats.relid)
        
        union all
        
        select * from (
            select
                epoch_ns,
                tag_datname,
                quote_ident(qr.root_schema) as tag_schema,
                quote_ident(qr.root_relname) as tag_table_name,
                quote_ident(qr.root_schema) || '.' || quote_ident(qr.root_relname) as tag_table_full_name,
                1 as is_part_root,
                sum(table_size_b)::int8 table_size_b,
                abs(greatest(ceil(log((sum(table_size_b) + 1) / 10 ^ 6)),
                      0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                sum(total_relation_size_b)::int8 total_relation_size_b,
                sum(toast_size_b)::int8 toast_size_b,
                min(seconds_since_last_vacuum)::int8 seconds_since_last_vacuum,
                min(seconds_since_last_analyze)::int8 seconds_since_last_analyze,
                sum(no_autovacuum)::int8 no_autovacuum,
                sum(seq_scan)::int8 seq_scan,
                sum(seq_tup_read)::int8 seq_tup_read,
                sum(idx_scan)::int8 idx_scan,
                sum(idx_tup_fetch)::int8 idx_tup_fetch,
                sum(n_tup_ins)::int8 n_tup_ins,
                sum(n_tup_upd)::int8 n_tup_upd,
                sum(n_tup_del)::int8 n_tup_del,
                sum(n_tup_hot_upd)::int8 n_tup_hot_upd,
                sum(n_live_tup)::int8 n_live_tup,
                sum(n_dead_tup)::int8 n_dead_tup,
                sum(vacuum_count)::int8 vacuum_count,
                sum(autovacuum_count)::int8 autovacuum_count,
                sum(analyze_count)::int8 analyze_count,
                sum(autoanalyze_count)::int8 autoanalyze_count,
                max(tx_freeze_age)::int8 tx_freeze_age
              from
                    q_tstats ts
                    join q_parts qp on qp.relid = ts.relid
                    join q_root_part qr on qr.oid = qp.root
              group by
                    1, 2, 3, 4, 5, 6
        ) x
        order by table_size_b desc nulls last limit 300
      16: |-
        with recursive /* pgwatch_generated */
            q_root_part as (
                select c.oid,
                        c.relkind,
                        n.nspname root_schema,
                        c.relname root_relname
                from pg_class c
                          join pg_namespace n on n.oid = c.relnamespace
                where relkind in ('p', 'r')
                  and relpersistence <> 't'
                  and not n.nspname like any (array[E'pg\\_%', 'information_schema', E'\\_timescaledb%'])
                  and not exists(select * from pg_inherits where inhrelid = c.oid)
                  and exists(select * from pg_inherits where inhparent = c.oid)
            ),
            q_parts (relid, relkind, level, root) as (
                select oid, relkind, 1, oid
                from q_root_part
                union all
                select inhrelid, c.relkind, level + 1, q.root
                from pg_inherits i
                          join q_parts q on inhparent = q.relid
                          join pg_class c on c.oid = i.inhrelid
            ),
            q_tstats as (
                select (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
                        current_database()                                                                       as tag_datname,
                        relid, -- not sent to final output
                        quote_ident(schemaname)                                                                  as tag_schema,
                        quote_ident(ut.relname)                                                                  as tag_table_name,
                        quote_ident(schemaname) || '.' || quote_ident(ut.relname)                                as tag_table_full_name,
                        pg_table_size(relid)                                                                     as table_size_b,
                        abs(greatest(ceil(log((pg_table_size(relid) + 1) / 10 ^ 6)), 0))::text                   as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                        pg_total_relation_size(relid)                                                            as total_relation_size_b,
                        case when c.reltoastrelid <> 0 then pg_total_relation_size(c.reltoastrelid) else 0::int8 end as toast_size_b,
                        (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8               as seconds_since_last_vacuum,
                        (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8             as seconds_since_last_analyze,
                        case when 'autovacuum_enabled=off' = ANY (c.reloptions) then 1 else 0 end                as no_autovacuum,
                        seq_scan,
                        seq_tup_read,
                        coalesce(idx_scan, 0) as idx_scan,
                        coalesce(idx_tup_fetch, 0) as idx_tup_fetch,
                        n_tup_ins,
                        n_tup_upd,
                        n_tup_del,
                        n_tup_hot_upd,
                        n_live_tup,
                        n_dead_tup,
                        vacuum_count,
                        autovacuum_count,
                        analyze_count,
                        autoanalyze_count,
                        case when c.relkind <> 'p' then age(c.relfrozenxid) else 0 end as tx_freeze_age,
                        extract(epoch from now() - last_seq_scan)::int8 as last_seq_scan_s
                from pg_stat_all_tables ut
                    join pg_class c on c.oid = ut.relid
                    left join pg_class t on t.oid = c.reltoastrelid
                    left join pg_index ti on ti.indrelid = t.oid
                    left join pg_class tir on tir.oid = ti.indexrelid
                where
                  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait
                  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock')
                  and c.relpersistence <> 't' -- and temp tables
                order by case when c.relkind = 'p' then 1e9::int else coalesce(c.relpages, 0) + coalesce(t.relpages, 0) + coalesce(tir.relpages, 0) end desc
                limit 1500 /* NB! When changing the bottom final LIMIT also adjust this limit. Should be at least 5x bigger as approx sizes depend a lot on vacuum frequency.
                            The general idea is to reduce filesystem "stat"-ing on tables that won't make it to final output anyways based on approximate size */
            )
        
        select /* pgwatch_generated */
            epoch_ns,
            tag_datname,
            tag_schema,
            tag_table_name,
            tag_table_full_name,
            0 as is_part_root,
            table_size_b,
            tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
            total_relation_size_b,
            toast_size_b,
            seconds_since_last_vacuum,
            seconds_since_last_analyze,
            no_autovacuum,
            seq_scan,
            seq_tup_read,
            idx_scan,
            idx_tup_fetch,
            n_tup_ins,
            n_tup_upd,
            n_tup_del,
            n_tup_hot_upd,
            n_live_tup,
            n_dead_tup,
            vacuum_count,
            autovacuum_count,
            analyze_count,
            autoanalyze_count,
            tx_freeze_age,
            last_seq_scan_s
        from q_tstats
        where not tag_schema like E'\\_timescaledb%'
        and not exists (select * from q_root_part where oid = q_tstats.relid)
        
        union all
        
        select * from (
            select
                epoch_ns,
                tag_datname,
                quote_ident(qr.root_schema) as tag_schema,
                quote_ident(qr.root_relname) as tag_table_name,
                quote_ident(qr.root_schema) || '.' || quote_ident(qr.root_relname) as tag_table_full_name,
                1 as is_part_root,
                sum(table_size_b)::int8 table_size_b,
                abs(greatest(ceil(log((sum(table_size_b) + 1) / 10 ^ 6)),
                      0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..
                sum(total_relation_size_b)::int8 total_relation_size_b,
                sum(toast_size_b)::int8 toast_size_b,
                min(seconds_since_last_vacuum)::int8 seconds_since_last_vacuum,
                min(seconds_since_last_analyze)::int8 seconds_since_last_analyze,
                sum(no_autovacuum)::int8 no_autovacuum,
                sum(seq_scan)::int8 seq_scan,
                sum(seq_tup_read)::int8 seq_tup_read,
                sum(idx_scan)::int8 idx_scan,
                sum(idx_tup_fetch)::int8 idx_tup_fetch,
                sum(n_tup_ins)::int8 n_tup_ins,
                sum(n_tup_upd)::int8 n_tup_upd,
                sum(n_tup_del)::int8 n_tup_del,
                sum(n_tup_hot_upd)::int8 n_tup_hot_upd,
                sum(n_live_tup)::int8 n_live_tup,
                sum(n_dead_tup)::int8 n_dead_tup,
                sum(vacuum_count)::int8 vacuum_count,
                sum(autovacuum_count)::int8 autovacuum_count,
                sum(analyze_count)::int8 analyze_count,
                sum(autoanalyze_count)::int8 autoanalyze_count,
                max(tx_freeze_age)::int8 tx_freeze_age,
                min(last_seq_scan_s)::int8 last_seq_scan_s
              from
                    q_tstats ts
                    join q_parts qp on qp.relid = ts.relid
                    join q_root_part qr on qr.oid = qp.root
              group by
                    1, 2, 3, 4, 5
        ) x
        order by table_size_b desc nulls last limit 300
    gauges:
      - table_size_b
      - total_relation_size_b
      - toast_size_b
      - seconds_since_last_vacuum
      - seconds_since_last_analyze
      - n_live_tup
      - n_dead_tup
    statement_timeout_seconds: 300
  wal:
    description: >
      This metric collects information about the Write-Ahead Logging (WAL) system in PostgreSQL.
      It provides insights into WAL activity, including the current WAL location, replay lag, and other related metrics.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          case
            when pg_is_in_recovery() = false then
              pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8
            else
              pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8
            end as xlog_location_b,
          case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,
          extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,
          system_identifier::text as tag_sys_id,
          case
            when pg_is_in_recovery() = false then
              ('x'||substr(pg_walfile_name(pg_current_wal_lsn()), 1, 8))::bit(32)::int
            else
              (select min_recovery_end_timeline::int from pg_control_recovery())
            end as timeline
        from pg_control_system()
    gauges:
      - '*'
    is_instance_level: true
    statement_timeout_seconds: 15
  wait_events:
    description: >
      This metric retrieves information about wait events for active sessions in the PostgreSQL database.
      It tracks the wait event types and counts of processes currently experiencing each wait event type,
      providing insights into potential bottlenecks and resource contention issues.
    sqls:
      11: |-
        select datname as tag_datname, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        from pg_stat_activity
        where state = 'active'
        group by tag_datname, tag_wait_event_type, tag_wait_event
        union
        select 'server_process' as tag_datname, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        from pg_stat_activity
        where state = 'active' and datname IS null 
        group by tag_datname, tag_wait_event_type, tag_wait_event
      14: |-
        select datname as tag_datname, query_id::text as tag_query_id, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        from pg_stat_activity
        where state = 'active'
        group by tag_datname, tag_query_id, tag_wait_event_type, tag_wait_event
        union
        select 'server_process' as tag_datname, null as tag_query_id, coalesce (wait_event, 'CPU*') as tag_wait_event, coalesce(wait_event_type, 'CPU*') as tag_wait_event_type, count(*) as total
        from pg_stat_activity
        where state = 'active' and datname IS null 
        group by tag_datname, tag_query_id, tag_wait_event_type, tag_wait_event
    gauges:
      - total
    is_instance_level: true
    statement_timeout_seconds: 15
  pg_stat_activity:
    sqls:
      11: |-
        select /* pgwatch_generated */
            pg_database.datname as tag_datname,
            tmp2.tag_application_name,
            tmp.tag_state,
            COALESCE(count,0) as count,
            COALESCE(max_tx_duration,0) as max_tx_duration
        from
          (
            VALUES ('active'),
                  ('idle'),
                  ('idle in transaction'),
                  ('idle in transaction (aborted)'),
                  ('fastpath function call'),
                  ('disabled')
          ) as tmp(tag_state)
        cross join pg_database
        left join
          (
            select datname,
              application_name as tag_application_name,
              state as tag_state,
              count(*) as count,
              MAX(extract(epoch from now() - xact_start))::float as max_tx_duration
            from pg_stat_activity
            group by datname, tag_application_name, tag_state
          ) as tmp2
        on tmp.tag_state = tmp2.tag_state and pg_database.datname = tmp2.datname
        where pg_database.datname = current_database()

    gauges:
      - count
      - max_tx_duration
    statement_timeout_seconds: 15
  pg_archiver:
    sqls:
      11: |
        WITH
          current_wal_file as (
            select case when not pg_is_in_recovery() then pg_walfile_name(pg_current_wal_insert_lsn()) else null end pg_walfile_name
          ),
          current_wal as (
            select
              ('x'||substring(pg_walfile_name,9,8))::bit(32)::int log,
              ('x'||substring(pg_walfile_name,17,8))::bit(32)::int seg,
              pg_walfile_name
            from current_wal_file
          ),
          archive_wal as(
            select
              ('x'||substring(last_archived_wal,9,8))::bit(32)::int log,
              ('x'||substring(last_archived_wal,17,8))::bit(32)::int seg,
              last_archived_wal
            from pg_stat_archiver
          )
        select (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname, 
          coalesce(((cw.log - aw.log) * 256) + (cw.seg-aw.seg), -1) as pending_wal_count 
        from current_wal cw, archive_wal aw
    gauges:
      - pending_wal_count
    statement_timeout_seconds: 15
  pg_blocked:
    sqls:
      11: |-
        select
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          count(*) as queries,
          case 
            when locktype = 'transactionid' then '__transaction__'
            else relation::regclass::text 
          end as tag_table
        from pg_catalog.pg_locks blocked
        where not blocked.granted
        group by locktype, relation
        limit 5000
    gauges:
      - queries
    statement_timeout_seconds: 15
  pg_database_wraparound:
    sqls:
      11: |
        select
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          datname as tag_datname,
          age(d.datfrozenxid) as age_datfrozenxid,
          mxid_age(d.datminmxid) as age_datminmxid
        from
          pg_catalog.pg_database d
        where
          d.datallowconn
    gauges:
      - age_datfrozenxid
      - age_datminmxid
    statement_timeout_seconds: 15
  pg_long_running_transactions:
    sqls:
      11: |
        select (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          COUNT(*) as transactions,
          COALESCE(MAX(extract(epoch from (clock_timestamp() - xact_start)))::int8, 0) as age_in_seconds
        from pg_catalog.pg_stat_activity
        where state is distinct from 'idle' and (now() - xact_start) > '1 minutes'::interval and query not like 'autovacuum:%'
    gauges:
      - '*'
    statement_timeout_seconds: 15
  pg_stat_replication:
    sqls:
      11: |
        select (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname, 
          application_name as tag_application_name, 
          (pg_current_wal_lsn() - '0/0') % (2^52)::bigint as current_wal_lsn, 
          (sent_lsn - '0/0') % (2^52)::bigint as sent_lsn, 
          (write_lsn - '0/0') % (2^52)::bigint as write_lsn, 
          (flush_lsn - '0/0') % (2^52)::bigint as flush_lsn, 
          (replay_lsn - '0/0') % (2^52)::bigint as replay_lsn,
          extract(seconds from (now() - reply_time)) reply_time_lag 
        from pg_stat_replication
    gauges:
      - current_wal_lsn
      - sent_lsn
      - write_lsn
      - flush_lsn
      - replay_lsn
      - reply_time_lag
    statement_timeout_seconds: 15
  pg_stat_statements:
    sqls:
      11: |
        WITH aggregated_statements as (
          select
            pg_database.datname,
            pg_stat_statements.queryid,
            sum(pg_stat_statements.plans) as plans_total,
            sum(pg_stat_statements.calls) as calls,
            sum(pg_stat_statements.total_exec_time) as exec_time_total,
            sum(pg_stat_statements.total_plan_time) as plan_time_total,
            sum(pg_stat_statements.rows) as rows,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_hit) as shared_bytes_hit_total,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_read) as shared_bytes_read_total,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_dirtied) as shared_bytes_dirtied_total,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_written) as shared_bytes_written_total,
            sum(pg_stat_statements.blk_read_time) as block_read_total,
            sum(pg_stat_statements.blk_write_time) as block_write_total,
            sum(pg_stat_statements.wal_records) as wal_records,
            sum(pg_stat_statements.wal_fpi) as wal_fpi,
            sum(pg_stat_statements.wal_bytes) as wal_bytes,
            sum(current_setting('block_size')::int * pg_stat_statements.temp_blks_read) as temp_bytes_read,
            sum(current_setting('block_size')::int * pg_stat_statements.temp_blks_written) as temp_bytes_written
            from pg_stat_statements
            join pg_database
            on pg_database.oid = pg_stat_statements.dbid
            group by pg_database.datname, pg_stat_statements.queryid
        )
        select
          datname as tag_datname,
          queryid as tag_queryid,
          calls::int8 as calls,
          plans_total::int8 as plans_total,
          exec_time_total::int8 as exec_time_total,
          plan_time_total::int8 as plan_time_total,
          rows::int8 as rows,
          shared_bytes_hit_total::int8 as shared_bytes_hit_total,
          shared_bytes_read_total::int8 as shared_bytes_read_total,
          shared_bytes_dirtied_total::int8 as shared_bytes_dirtied_total,
          shared_bytes_written_total::int8 as shared_bytes_written_total,
          block_read_total::int8 as block_read_total,
          block_write_total::int8 as block_write_total,
          wal_records::int8 as wal_records,
          wal_fpi::int8 as wal_fpi,
          wal_bytes::int8 as wal_bytes,
          temp_bytes_read::int8 as temp_bytes_read,
          temp_bytes_written::int8 as temp_bytes_written
          from aggregated_statements
      17: |
        with aggregated_statements as (
          select
            pg_database.datname,
            pg_stat_statements.queryid,
            sum(pg_stat_statements.plans) as plans_total,
            sum(pg_stat_statements.calls) as calls,
            sum(pg_stat_statements.total_exec_time) as exec_time_total,
            sum(pg_stat_statements.total_plan_time) as plan_time_total,
            sum(pg_stat_statements.rows) as rows,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_hit) as shared_bytes_hit_total,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_read) as shared_bytes_read_total,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_dirtied) as shared_bytes_dirtied_total,
            sum(current_setting('block_size')::int * pg_stat_statements.shared_blks_written) as shared_bytes_written_total,
            sum(pg_stat_statements.shared_blk_read_time) as block_read_total,
            sum(pg_stat_statements.shared_blk_write_time) as block_write_total,
            sum(pg_stat_statements.wal_records) as wal_records,
            sum(pg_stat_statements.wal_fpi) as wal_fpi,
            sum(pg_stat_statements.wal_bytes) as wal_bytes,
            sum(current_setting('block_size')::int * pg_stat_statements.temp_blks_read) as temp_bytes_read,
            sum(current_setting('block_size')::int * pg_stat_statements.temp_blks_written) as temp_bytes_written
            from pg_stat_statements
            join pg_database
            on pg_database.oid = pg_stat_statements.dbid
            group by pg_database.datname, pg_stat_statements.queryid
        )
        select
          datname as tag_datname,
          queryid as tag_queryid,
          calls::int8 as calls,
          plans_total::int8 as plans_total,
          exec_time_total::int8 as exec_time_total,
          plan_time_total::int8 as plan_time_total,
          rows::int8 as rows,
          shared_bytes_hit_total::int8 as shared_bytes_hit_total,
          shared_bytes_read_total::int8 as shared_bytes_read_total,
          shared_bytes_dirtied_total::int8 as shared_bytes_dirtied_total,
          shared_bytes_written_total::int8 as shared_bytes_written_total,
          block_read_total::int8 as block_read_total,
          block_write_total::int8 as block_write_total,
          wal_records::int8 as wal_records,
          wal_fpi::int8 as wal_fpi,
          wal_bytes::int8 as wal_bytes,
          temp_bytes_read::int8 as temp_bytes_read,
          temp_bytes_written::int8 as temp_bytes_written
          from aggregated_statements
    gauges:
      - calls
      - plans_total
      - exec_time_total
      - plan_time_total
      - rows
      - shared_bytes_hit_total
      - shared_bytes_read_total
      - shared_bytes_dirtied_total
      - shared_bytes_written_total
      - block_read_total
      - block_write_total
      - wal_records
      - wal_fpi
      - wal_bytes
      - temp_bytes_read
      - temp_bytes_written
    statement_timeout_seconds: 15
  pg_class:
    description: >
      Direct access to pg_class system catalog data for all relations (tables, indexes, etc).
      Provides reltuples, relpages, and other pg_class columns with relname and schemaname
      as tags for easy filtering and querying.
    sqls:
      11: |
        select 
          current_database() as tag_datname,
          n.nspname as tag_schemaname,
          c.relname as tag_relname,
          c.relkind as tag_relkind,
          c.reltuples,
          c.relpages,
          pg_relation_size(c.oid) as relation_size_bytes,
          pg_total_relation_size(c.oid) as total_relation_size_bytes
        from pg_class c
        join pg_namespace n on n.oid = c.relnamespace
        where n.nspname not in ('information_schema', 'pg_catalog')
          and c.relkind in ('r', 'i', 'm', 'v')  -- tables, indexes, materialized views, views
        order by pg_total_relation_size(c.oid) desc
        limit 10000
    gauges:
      - reltuples
      - relpages
      - relation_size_bytes
      - total_relation_size_bytes
    statement_timeout_seconds: 15
  pg_stat_all_indexes:
    sqls:
      11: |
        select schemaname as tag_schemaname, 
          relname as tag_relname, 
          indexrelname as tag_indexrelname, 
          idx_scan, 
          idx_tup_read, 
          idx_tup_fetch
        from pg_stat_all_indexes
        order by idx_scan desc
        limit 5000
    gauges:
      - idx_scan
      - idx_tup_read
      - idx_tup_fetch
    statement_timeout_seconds: 15
  pg_stat_all_tables:
    sqls:
      11: |
        select
          current_database() as tag_datname,
          schemaname as tag_schemaname,
          relname as tag_relname,
          seq_scan,
          seq_tup_read,
          idx_scan,
          idx_tup_fetch,
          n_tup_ins,
          n_tup_upd,
          n_tup_del,
          n_tup_hot_upd,
          n_live_tup,
          n_dead_tup,
          GREATEST(last_autovacuum, last_vacuum, '1970-01-01Z') as last_vacuum,
          GREATEST(last_autoanalyze, last_analyze, '1970-01-01Z') as last_analyze,
          (vacuum_count + autovacuum_count) as vacuum_count,
          (analyze_count + autoanalyze_count) as analyze_count
        from
          pg_stat_all_tables
        order by n_live_tup + n_dead_tup desc
        limit 5000
    gauges:
      - seq_scan
      - seq_tup_read
      - idx_scan
      - idx_tup_fetch
      - n_tup_ins
      - n_tup_upd
      - n_tup_del
      - n_tup_hot_upd
      - n_live_tup
      - n_dead_tup
      - last_vacuum
      - last_analyze
      - vacuum_count
      - analyze_count
    statement_timeout_seconds: 15
  pg_stat_wal_receiver:
    sqls:
      11: |
        select current_database() as tag_datname,
        case status when 'stopped' then 0 when 'starting' then 1 when 'streaming' then 2 when 'waiting' then 3 when 'restarting' then 4 when 'stopping' then 5 else -1 end as tag_status,
              (receive_start_lsn- '0/0') % (2^52)::bigint as receive_start_lsn,
              receive_start_tli,
              (flushed_lsn- '0/0') % (2^52)::bigint as flushed_lsn,
              received_tli,
              extract(epoch from last_msg_send_time) as last_msg_send_time,
              extract(epoch from last_msg_receipt_time) as last_msg_receipt_time,
              (latest_end_lsn - '0/0') % (2^52)::bigint as latest_end_lsn,
              extract(epoch from latest_end_time) as latest_end_time,
              substring(slot_name from 'repmgr_slot_([0-9]*)') as upstream_node,
              trim(both '''' from substring(conninfo from 'host=([^ ]*)')) as tag_upstream_host,
              slot_name
          from pg_catalog.pg_stat_wal_receiver
    gauges:
      - status
      - receive_start_lsn
      - receive_start_tli
      - flushed_lsn
      - received_tli
      - last_msg_send_time
      - last_msg_receipt_time
      - latest_end_lsn
      - latest_end_time
      - upstream_node
    statement_timeout_seconds: 15
  pg_stat_slru:
    description: >
      Retrieves statistics from the PostgreSQL `pg_stat_slru` view for SLRU (Simple Least Recently Used) caches.
      It tracks various SLRU caches like subtrans, multixact_offset, multixact_member, notify, serial, and clog.
      Each cache reports blocks zeroed, hit, read, written, exists checks, flushes, truncates, and last stats reset time.
      This metric helps administrators monitor SLRU cache performance and identify potential issues with transaction ID wraparound or other system caches.
    sqls:
      11: "; -- not available before PG 13"
      13: |-
        select /* pgwatch_generated */
          current_database() as tag_datname,
          name as tag_name,
          blks_zeroed,
          blks_hit,
          blks_read,
          blks_written,
          blks_exists,
          flushes,
          truncates,
          extract(epoch from stats_reset)::int8 as stats_reset_epoch
        from pg_stat_slru
    gauges:
      - blks_zeroed
      - blks_hit
      - blks_read
      - blks_written
      - blks_exists
      - flushes
      - truncates
      - stats_reset_epoch
    statement_timeout_seconds: 15
  pg_stuck_idle_in_transaction:
    sqls:
      11: |
        select current_database() as tag_datname, COUNT(*) as queries
        from pg_catalog.pg_stat_activity
        where state = 'idle in transaction' and (now() - query_start) > '10 minutes'::interval
    gauges:
      - queries
    statement_timeout_seconds: 15
  pg_total_relation_size:
    sqls:
      11: |
        select current_database() as tag_datname,
        relnamespace::regnamespace as tag_schemaname,
              relname as tag_relname,
              pg_total_relation_size(oid) bytes
          from pg_class
        where relkind = 'r'
        order by bytes desc
        limit 5000
    gauges:
      - bytes
    statement_timeout_seconds: 15
  pg_txid:
    sqls:
      11: |
        select
          current_database() as tag_datname,
          case when pg_is_in_recovery() then 'NaN'::float else txid_current() % (2^52)::bigint end as current,
          case when pg_is_in_recovery() then 'NaN'::float else txid_snapshot_xmin(txid_current_snapshot()) % (2^52)::bigint end as xmin,
          case when pg_is_in_recovery() then 'NaN'::float else txid_current() - txid_snapshot_xmin(txid_current_snapshot()) end as xmin_age
    gauges:
      - current
      - xmin
      - xmin_age
    statement_timeout_seconds: 15
  pg_xlog_position:
    sqls:
      11: |
        select current_database() as tag_datname,
        case
              when pg_is_in_recovery()
              then (pg_last_wal_replay_lsn() - '0/0') % (2^52)::bigint
              else (pg_current_wal_lsn() - '0/0') % (2^52)::bigint
              end as bytes
    gauges:
      - bytes
    statement_timeout_seconds: 15
  pg_btree_bloat:
    description: >
      This metric analyzes index bloat by calculating the estimated vs actual index pages and sizes.
      It provides insights into index bloat percentage, real size, extra size due to bloat, and bloat size considering fill factor.
      This metric helps administrators identify indexes that may need maintenance like VACUUM FULL or index reorganization.
    sqls:
      11: | 
        select current_database() as tag_datname, nspname as tag_schemaname, tblname as tag_tblname, idxname as tag_idxname, (bs*(relpages)/(1024*1024))::float as real_size_mib,
          (bs*(relpages-est_pages))::float as extra_size,
          100 * (relpages-est_pages)::float / relpages as extra_pct,
          fillfactor,
          case when relpages > est_pages_ff
            then bs*(relpages-est_pages_ff)
            else 0
          end as bloat_size,
          100 * (relpages-est_pages_ff)::float / relpages as bloat_pct,
          is_na
          -- , 100-(pst).avg_leaf_density as pst_avg_bloat, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples, relpages -- (DEBUG INFO)
        from (
          select coalesce(1 +
                ceil(reltuples/floor((bs-pageopqdata-pagehdr)/(4+nulldatahdrwidth)::float)), 0 -- ItemIdData size + computed avg size of a tuple (nulldatahdrwidth)
              ) as est_pages,
              coalesce(1 +
                ceil(reltuples/floor((bs-pageopqdata-pagehdr)*fillfactor/(100*(4+nulldatahdrwidth)::float))), 0
              ) as est_pages_ff,
              bs, nspname, tblname, idxname, relpages, fillfactor, is_na
              -- , pgstatindex(idxoid) as pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG INFO)
          from (
              select maxalign, bs, nspname, tblname, idxname, reltuples, relpages, idxoid, fillfactor,
                    ( index_tuple_hdr_bm +
                        maxalign - case -- Add padding to the index tuple header to align on MAXALIGN
                          when index_tuple_hdr_bm%maxalign = 0 then maxalign
                          else index_tuple_hdr_bm%maxalign
                        end
                      + nulldatawidth + maxalign - case -- Add padding to the data to align on MAXALIGN
                          when nulldatawidth = 0 then 0
                          when nulldatawidth::integer%maxalign = 0 then maxalign
                          else nulldatawidth::integer%maxalign
                        end
                    )::numeric as nulldatahdrwidth, pagehdr, pageopqdata, is_na
                    -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)
              from (
                  select n.nspname, i.tblname, i.idxname, i.reltuples, i.relpages,
                      i.idxoid, i.fillfactor, current_setting('block_size')::numeric as bs,
                      case -- MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?)
                        when version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64' then 8
                        else 4
                      end as maxalign,
                      /* per page header, fixed size: 20 for 7.X, 24 for others */
                      24 as pagehdr,
                      /* per page btree opaque data */
                      16 as pageopqdata,
                      /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */
                      case when max(coalesce(s.null_frac,0)) = 0
                          then 8 -- IndexTupleData size
                          else 8 + (( 32 + 8 - 1 ) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8 - 1 /8)
                      end as index_tuple_hdr_bm,
                      /* data len: we remove null values save space using it fractionnal part from stats */
                      sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) as nulldatawidth,
                      (max( case when i.atttypid = 'pg_catalog.name'::regtype then 1 else 0 end ) > 0)::int as is_na
                  from (
                      select ct.relname as tblname, ct.relnamespace, ic.idxname, ic.attpos, ic.indkey, ic.indkey[ic.attpos], ic.reltuples, ic.relpages, ic.tbloid, ic.idxoid, ic.fillfactor,
                          coalesce(a1.attnum, a2.attnum) as attnum, coalesce(a1.attname, a2.attname) as attname, coalesce(a1.atttypid, a2.atttypid) as atttypid,
                          case when a1.attnum IS null
                          then ic.idxname
                          else ct.relname
                          end as attrelname
                      from (
                          select idxname, reltuples, relpages, tbloid, idxoid, fillfactor, indkey,
                              pg_catalog.generate_series(1,indnatts) as attpos
                          from (
                              select ci.relname as idxname, ci.reltuples, ci.relpages, i.indrelid as tbloid,
                                  i.indexrelid as idxoid,
                                  coalesce(substring(
                                      array_to_string(ci.reloptions, ' ')
                                      from 'fillfactor=([0-9]+)')::smallint, 90) as fillfactor,
                                  i.indnatts,
                                  pg_catalog.string_to_array(pg_catalog.textin(
                                      pg_catalog.int2vectorout(i.indkey)),' ')::int[] as indkey
                              from pg_catalog.pg_index i
                              join pg_catalog.pg_class ci on ci.oid = i.indexrelid
                              where ci.relam=(select oid from pg_am where amname = 'btree')
                              and ci.relpages > 0
                          ) as idx_data
                      ) as ic
                      join pg_catalog.pg_class ct on ct.oid = ic.tbloid
                      left join pg_catalog.pg_attribute a1 on
                          ic.indkey[ic.attpos] <> 0
                          and a1.attrelid = ic.tbloid
                          and a1.attnum = ic.indkey[ic.attpos]
                      left join pg_catalog.pg_attribute a2 on
                          ic.indkey[ic.attpos] = 0
                          and a2.attrelid = ic.idxoid
                          and a2.attnum = ic.attpos
                    ) i
                    join pg_catalog.pg_namespace n on n.oid = i.relnamespace
                                join public.pg_statistic s on s.schemaname = n.nspname
                                      and s.tablename = i.attrelname
                                      and s.attname = i.attname
                    group by 1,2,3,4,5,6,7,8,9,10,11
              ) as rows_data_stats
          ) as rows_hdr_pdg_stats
        ) as relation_stats
        order by real_size_mib desc
        limit 5000
    gauges:
      - real_size_mib
      - extra_size
      - extra_pct
      - fillfactor
      - bloat_size
      - bloat_pct
      - is_na
      - reltuples
    statement_timeout_seconds: 15
  pg_table_bloat:
    description: >
      This metric analyzes table bloat by calculating the estimated vs actual table pages and sizes.
      It provides insights into table bloat percentage, real size, extra size due to bloat, and bloat size considering fill factor.
      This metric helps administrators identify tables that may need maintenance like VACUUM FULL or table reorganization.
    sqls:
      11: |
        select current_database() as tag_datname, schemaname as tag_schemaname, tblname as tag_tblname, (bs*tblpages)/(1024*1024)::float as real_size_mib,
          (tblpages-est_tblpages)*bs as extra_size,
          case when tblpages > 0 and tblpages - est_tblpages > 0
            then 100 * (tblpages - est_tblpages)/tblpages::float
            else 0
          end as extra_pct, fillfactor,
          case when tblpages - est_tblpages_ff > 0
            then (tblpages-est_tblpages_ff)*bs
            else 0
          end as bloat_size,
          case when tblpages > 0 and tblpages - est_tblpages_ff > 0
            then 100 * (tblpages - est_tblpages_ff)/tblpages::float
            else 0
          end as bloat_pct, is_na
          -- , tpl_hdr_size, tpl_data_size, (pst).free_percent + (pst).dead_tuple_percent as real_frag -- (DEBUG INFO)
        from (
          select ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) as est_tblpages,
            ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) as est_tblpages_ff,
            tblpages, fillfactor, bs, tblid, schemaname, tblname, heappages, toastpages, is_na
            -- , tpl_hdr_size, tpl_data_size, pgstattuple(tblid) as pst -- (DEBUG INFO)
          from (
            select
              ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)
                - case when tpl_hdr_size%ma = 0 then ma else tpl_hdr_size%ma end
                - case when ceil(tpl_data_size)::int%ma = 0 then ma else ceil(tpl_data_size)::int%ma end
              ) as tpl_size, bs - page_hdr as size_per_block, (heappages + toastpages) as tblpages, heappages,
              toastpages, reltuples, toasttuples, bs, page_hdr, tblid, schemaname, tblname, fillfactor, is_na
              -- , tpl_hdr_size, tpl_data_size
            from (
              select
                tbl.oid as tblid, ns.nspname as schemaname, tbl.relname as tblname, tbl.reltuples,
                tbl.relpages as heappages, coalesce(toast.relpages, 0) as toastpages,
                coalesce(toast.reltuples, 0) as toasttuples,
                coalesce(substring(
                  array_to_string(tbl.reloptions, ' ')
                  from 'fillfactor=([0-9]+)')::smallint, 100) as fillfactor,
                current_setting('block_size')::numeric as bs,
                case when version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' then 8 else 4 end as ma,
                24 as page_hdr,
                23 + case when MAX(coalesce(s.null_frac,0)) > 0 then ( 7 + count(s.attname) ) / 8 else 0::int end
                  + case when bool_or(att.attname = 'oid' and att.attnum < 0) then 4 else 0 end as tpl_hdr_size,
                sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) as tpl_data_size,
                (bool_or(att.atttypid = 'pg_catalog.name'::regtype)
                  OR sum(case when att.attnum > 0 then 1 else 0 end) <> count(s.attname))::int as is_na
              from pg_attribute as att
                join pg_class as tbl on att.attrelid = tbl.oid
                join pg_namespace as ns on ns.oid = tbl.relnamespace
                left join public.pg_statistic as s on s.schemaname=ns.nspname
                  and s.tablename = tbl.relname and s.inherited=false and s.attname=att.attname
                left join pg_class as toast on tbl.reltoastrelid = toast.oid
              where not att.attisdropped
                and tbl.relkind in ('r','m')
              group by 1,2,3,4,5,6,7,8,9,10
              order by 2,3
            ) as s
          ) as s2
        ) as s3
        -- where not is_na
        --   and tblpages*((pst).free_percent + (pst).dead_tuple_percent)::float4/100 >= 1
        order by real_size_mib desc
        limit 5000
    gauges:
      - real_size_mib
      - extra_size
      - extra_pct
      - fillfactor
      - bloat_size
      - bloat_pct
      - is_na
      - reltuples
    statement_timeout_seconds: 300
  table_size_detailed:
    description: >
      This metric provides comprehensive table size analysis including the actual table size (main data fork only),
      TOAST table size, index size, free space map (FSM) size, and visibility map (VM) size.
      It helps administrators understand detailed storage breakdown for each table component.
    sqls:
      11: |-
        with table_sizes as (
          select
            (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
            current_database() as tag_datname,
            n.nspname as tag_schema,
            c.relname as tag_table_name,
            c.oid as table_oid,
            c.reltoastrelid,
            -- Main table size components (bytes)
            pg_relation_size(c.oid, 'main') as table_main_size_b,
            pg_relation_size(c.oid, 'fsm') as table_fsm_size_b,
            pg_relation_size(c.oid, 'vm') as table_vm_size_b,
            pg_indexes_size(c.oid) as table_indexes_size_b,
            pg_relation_size(c.reltoastrelid, 'main') as toast_main_size_b,
            pg_relation_size(c.reltoastrelid, 'fsm') as toast_fsm_size_b,
            pg_relation_size(c.reltoastrelid, 'vm') as toast_vm_size_b,
            pg_indexes_size(c.reltoastrelid) as toast_indexes_size_b,
            pg_total_relation_size(c.reltoastrelid) as toast_total_size_b,
            pg_total_relation_size(c.oid) as total_relation_size_b,
            abs(greatest(ceil(log((pg_total_relation_size(c.oid) + 1) / 10 ^ 6)), 0))::text as tag_size_cardinality_mb
          from pg_class c
          join pg_namespace n on n.oid = c.relnamespace
          where c.relkind in ('r', 'p', 'm') -- regular tables, partitioned tables, materialized views
            and n.nspname not in ('information_schema', 'pg_toast')
            and not exists (
              select 1 from pg_locks 
              where relation = c.oid and mode = 'AccessExclusiveLock'
            )
          order by pg_total_relation_size(c.oid) desc
        )
        select /* pgwatch_generated */
          epoch_ns,
          tag_datname,
          tag_schema,
          tag_table_name,
          tag_size_cardinality_mb,
          table_main_size_b,
          table_fsm_size_b,
          table_vm_size_b,
          table_indexes_size_b,
          toast_main_size_b,
          toast_fsm_size_b,
          toast_vm_size_b,
          toast_indexes_size_b,
          total_relation_size_b,
          (toast_main_size_b + toast_fsm_size_b + toast_vm_size_b + toast_indexes_size_b) as total_toast_size_b
        from table_sizes
        where total_relation_size_b > 0
    gauges:
      - table_main_size_b
      - table_fsm_size_b  
      - table_vm_size_b
      - table_indexes_size_b
      - toast_main_size_b
      - toast_fsm_size_b
      - toast_vm_size_b
      - toast_indexes_size_b
      - total_relation_size_b
      - actual_data_size_b
      - metadata_size_b
      - total_indexes_size_b
      - total_toast_size_b
    statement_timeout_seconds: 15
  pg_invalid_indexes:
    description: >
      This metric identifies invalid indexes in the database.
      It provides insights into the number of invalid indexes and their details.
      This metric helps administrators identify and fix invalid indexes to improve database performance.
    sqls:
      11: |
        with fk_indexes as (
          select
            schemaname as tag_schema_name,
            (indexrelid::regclass)::text as tag_index_name,
            (relid::regclass)::text as tag_table_name,
            (confrelid::regclass)::text as tag_fk_table_ref,
            array_to_string(indclass, ', ') as tag_opclasses
          from
            pg_stat_all_indexes
          join pg_index using (indexrelid)
          left join pg_constraint
            on array_to_string(indkey, ',') = array_to_string(conkey, ',')
              and schemaname = (connamespace::regnamespace)::text
              and conrelid = relid
              and contype = 'f'
          where idx_scan = 0
            and indisunique is false
            and conkey is not null --conkey is not null then true else false end as is_fk_idx
        ), data as (
          select
            pci.relname as tag_index_name,
            pn.nspname as tag_schema_name,
            pct.relname as tag_table_name,
            quote_ident(pn.nspname) as tag_schema_name,
            quote_ident(pci.relname) as tag_index_name,
            quote_ident(pct.relname) as tag_table_name,
            coalesce(nullif(quote_ident(pn.nspname), 'public') || '.', '') || quote_ident(pct.relname) as tag_relation_name,
            pg_relation_size(pidx.indexrelid) index_size_bytes,
            ((
              select count(1)
              from fk_indexes fi
              where
                fi.tag_fk_table_ref = pct.relname
                and fi.tag_opclasses like (array_to_string(pidx.indclass, ', ') || '%')
            ) > 0)::int as supports_fk
          from pg_index pidx
          join pg_class as pci on pci.oid = pidx.indexrelid
          join pg_class as pct on pct.oid = pidx.indrelid
          left join pg_namespace pn on pn.oid = pct.relnamespace
          where pidx.indisvalid = false
        ), data_total as (
            select
              sum(index_size_bytes) as index_size_bytes_sum
            from data
        ), num_data as (
          select
            row_number() over () num,
            data.*
          from data
        )
        select
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          num_data.*
        from num_data;
    gauges:
      - '*'
    statement_timeout_seconds: 15
  redundant_indexes:
    description: >
      This metric identifies redundant indexes that can potentially be dropped to save storage space and improve write performance.
      It analyzes index relationships and finds indexes that are covered by other indexes, considering column order, operator classes,
      and foreign key constraints. Uses the exact logic from tmp.sql with JSON aggregation and proper thresholds.
    sqls:
      11: |
        with fk_indexes as (
          select
            n.nspname as schema_name,
            ci.relname as index_name,
            cr.relname as table_name,
            (confrelid::regclass)::text as fk_table_ref,
            array_to_string(indclass, ', ') as opclasses
          from pg_index i
          join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
          join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
          join pg_namespace n on n.oid = ci.relnamespace
          join pg_constraint cn on cn.conrelid = cr.oid
          left join pg_stat_all_indexes as si on si.indexrelid = i.indexrelid
          where
            contype = 'f'
            and i.indisunique is false
            and conkey is not null
            and ci.relpages > 5
            and si.idx_scan < 10
        ),
        -- Redundant indexes
        index_data as (
          select
            *,
            indkey::text as columns,
            array_to_string(indclass, ', ') as opclasses
          from pg_index i
          join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
          where indisvalid = true and ci.relpages > 5
        ), redundant_indexes as (
          select
            i2.indexrelid as index_id,
            tnsp.nspname AS schema_name,
            trel.relname AS table_name,
            pg_relation_size(trel.oid) as table_size_bytes,
            irel.relname AS index_name,
            am1.amname as access_method,
            (i1.indexrelid::regclass)::text as reason,
            i1.indexrelid as reason_index_id,
            pg_get_indexdef(i1.indexrelid) main_index_def,
            pg_size_pretty(pg_relation_size(i1.indexrelid)) main_index_size,
            pg_get_indexdef(i2.indexrelid) index_def,
            pg_relation_size(i2.indexrelid) index_size_bytes,
            s.idx_scan as index_usage,
            quote_ident(tnsp.nspname) as formated_schema_name,
            coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(irel.relname) as formated_index_name,
            quote_ident(trel.relname) AS formated_table_name,
            coalesce(nullif(quote_ident(tnsp.nspname), 'public') || '.', '') || quote_ident(trel.relname) as formated_relation_name,
            i2.opclasses
          from (
            select indrelid, indexrelid, opclasses, indclass, indexprs, indpred, indisprimary, indisunique, columns
              from index_data
              order by indexrelid
            ) as i1
            join index_data as i2 on (
                i1.indrelid = i2.indrelid -- same table
                and i1.indexrelid <> i2.indexrelid -- NOT same index
            )
            inner join pg_opclass op1 on i1.indclass[0] = op1.oid
            inner join pg_opclass op2 on i2.indclass[0] = op2.oid
            inner join pg_am am1 on op1.opcmethod = am1.oid
            inner join pg_am am2 on op2.opcmethod = am2.oid
            join pg_stat_all_indexes as s on s.indexrelid = i2.indexrelid
            join pg_class as trel on trel.oid = i2.indrelid
            join pg_namespace as tnsp on trel.relnamespace = tnsp.oid
            join pg_class as irel on irel.oid = i2.indexrelid
          where
            not i2.indisprimary -- index 1 is not primary
            and not ( -- skip if index1 is (primary or uniq) and is NOT (primary and uniq)
                i2.indisunique and not i1.indisprimary
            )
            and  am1.amname = am2.amname -- same access type
            and i1.columns like (i2.columns || '%') -- index 2 includes all columns from index 1
            and i1.opclasses like (i2.opclasses || '%')
            -- index expressions is same
            and pg_get_expr(i1.indexprs, i1.indrelid) is not distinct from pg_get_expr(i2.indexprs, i2.indrelid)
            -- index predicates is same
            and pg_get_expr(i1.indpred, i1.indrelid) is not distinct from pg_get_expr(i2.indpred, i2.indrelid)
        ), redundant_indexes_fk as (
          select
            ri.*,
            ((
              select count(1)
              from fk_indexes fi
              where
                fi.fk_table_ref = ri.table_name
                and fi.opclasses like (ri.opclasses || '%')
            ) > 0)::int as supports_fk
          from redundant_indexes ri
        ),
        -- Cut recursive links
        redundant_indexes_tmp_num as (
          select row_number() over () num, rig.*
          from redundant_indexes_fk rig
        ), redundant_indexes_tmp_links as (
            select
            ri1.*,
            ri2.num as r_num
            from redundant_indexes_tmp_num ri1
            left join redundant_indexes_tmp_num ri2 on ri2.reason_index_id = ri1.index_id and ri1.reason_index_id = ri2.index_id
        ), redundant_indexes_tmp_cut as (
            select
            *
            from redundant_indexes_tmp_links
            where num < r_num or r_num is null
        ), redundant_indexes_cut_grouped as (
          select
            distinct(num),
            *
          from redundant_indexes_tmp_cut
          order by index_size_bytes desc
        ), redundant_indexes_grouped as (
          select
            index_id,
            schema_name as tag_schema_name,
            table_name,
            table_size_bytes,
            index_name as tag_index_name,
            access_method as tag_access_method,
            string_agg(distinct reason, ', ') as tag_reason,
            index_size_bytes,
            index_usage,
            formated_index_name as tag_index_name,
            formated_schema_name as tag_schema_name,
            formated_table_name as tag_table_name,
            formated_relation_name as tag_relation_name,
            supports_fk::int as supports_fk
          from redundant_indexes_cut_grouped
          group by
            index_id,
            table_size_bytes,
            schema_name,
            table_name,
            index_name,
            access_method,
            index_def,
            index_size_bytes,
            index_usage,
            formated_index_name,
            formated_schema_name,
            formated_table_name,
            formated_relation_name,
            supports_fk
          order by index_size_bytes desc
        )
        select * from redundant_indexes_grouped;
    gauges:
      - '*'
    statement_timeout_seconds: 15
  unused_indexes:
    description: >
      This metric identifies unused indexes in the database.
      It provides insights into the number of unused indexes and their details.
      This metric helps administrators identify and fix unused indexes to improve database performance.
    sqls:
      11: | 
        with fk_indexes as (
          select
            n.nspname as schema_name,
            ci.relname as index_name,
            cr.relname as table_name,
            (confrelid::regclass)::text as fk_table_ref,
            array_to_string(indclass, ', ') as opclasses
          from pg_index i
          join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
          join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
          join pg_namespace n on n.oid = ci.relnamespace
          join pg_constraint cn on cn.conrelid = cr.oid
          left join pg_stat_all_indexes as si on si.indexrelid = i.indexrelid
          where
            contype = 'f'
            and i.indisunique is false
            and conkey is not null
            and ci.relpages > 5
            and si.idx_scan < 10
        ), table_scans as (
          select relid,
              tables.idx_scan + tables.seq_scan as all_scans,
              ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes,
            pg_relation_size(relid) as table_size
              from pg_stat_all_tables as tables
              join pg_class c on c.oid = relid
              where c.relpages > 5
        ), indexes as (
          select
            i.indrelid,
            i.indexrelid,
            n.nspname as schema_name,
            cr.relname as table_name,
            ci.relname as index_name,
            si.idx_scan,
            pg_relation_size(i.indexrelid) as index_bytes,
            ci.relpages,
            (case when a.amname = 'btree' then true else false end) as idx_is_btree,
            array_to_string(i.indclass, ', ') as opclasses
          from pg_index i
            join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
            join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
            join pg_namespace n on n.oid = ci.relnamespace
            join pg_am a ON ci.relam = a.oid
            left join pg_stat_all_indexes as si on si.indexrelid = i.indexrelid
          where
            i.indisunique = false
            and i.indisvalid = true
            and ci.relpages > 5
        ), index_ratios as (
          select
            i.indexrelid as index_id,
            i.schema_name,
            i.table_name,
            i.index_name,
            idx_scan,
            all_scans,
            round(( case when all_scans = 0 then 0.0::numeric
              else idx_scan::numeric/all_scans * 100 end), 2) as index_scan_pct,
            writes,
            round((case when writes = 0 then idx_scan::numeric else idx_scan::numeric/writes end), 2)
              as scans_per_write,
            index_bytes as index_size_bytes,
            table_size as table_size_bytes,
            i.relpages,
            idx_is_btree,
            i.opclasses,
            (
              select count(1)
              from fk_indexes fi
              where fi.fk_table_ref = i.table_name
                and fi.schema_name = i.schema_name
                and fi.opclasses like (i.opclasses || '%')
            ) > 0 as supports_fk
          from indexes i
          join table_scans ts on ts.relid = i.indrelid
        )
        select
          'Never Used Indexes' as tag_reason,
          index_id,
          schema_name AS tag_schema_name,
          table_name AS tag_table_name,
          index_name AS tag_index_name,
          idx_scan,
          all_scans,
          index_scan_pct,
          writes,
          scans_per_write,
          index_size_bytes,
          table_size_bytes,
          relpages,
          idx_is_btree,
          opclasses AS tag_opclasses,
          supports_fk
        from index_ratios
        where
          idx_scan = 0
          and idx_is_btree
        order by index_size_bytes desc;
    gauges:
      - '*'
    statement_timeout_seconds: 15
  rarely_used_indexes:
    description: >
      This metric identifies rarely used indexes in the database.
      It provides insights into the number of rarely used indexes and their details.
      This metric helps administrators identify and fix rarely used indexes to improve database performance.
    sqls:
      11: |
        with fk_indexes as (
          select
            n.nspname as schema_name,
            ci.relname as index_name,
            cr.relname as table_name,
            (confrelid::regclass)::text as fk_table_ref,
            array_to_string(indclass, ', ') as opclasses
          from pg_index i
          join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
          join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
          join pg_namespace n on n.oid = ci.relnamespace
          join pg_constraint cn on cn.conrelid = cr.oid
          left join pg_stat_all_indexes as si on si.indexrelid = i.indexrelid
          where
            contype = 'f'
            and i.indisunique is false
            and conkey is not null
            and ci.relpages > 5
            and si.idx_scan < 10
        ), table_scans as (
          select relid,
              tables.idx_scan + tables.seq_scan as all_scans,
              ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes,
            pg_relation_size(relid) as table_size
              from pg_stat_all_tables as tables
              join pg_class c on c.oid = relid
              where c.relpages > 5
        ), all_writes as (
          select sum(writes) as total_writes
          from table_scans
        ), indexes as (
          select
            i.indrelid,
            i.indexrelid,
            n.nspname as schema_name,
            cr.relname as table_name,
            ci.relname as index_name,
            si.idx_scan,
            pg_relation_size(i.indexrelid) as index_bytes,
            ci.relpages,
            (case when a.amname = 'btree' then true else false end) as idx_is_btree,
            array_to_string(i.indclass, ', ') as opclasses
          from pg_index i
            join pg_class ci on ci.oid = i.indexrelid and ci.relkind = 'i'
            join pg_class cr on cr.oid = i.indrelid and cr.relkind = 'r'
            join pg_namespace n on n.oid = ci.relnamespace
            join pg_am a ON ci.relam = a.oid
            left join pg_stat_all_indexes as si on si.indexrelid = i.indexrelid
          where
            i.indisunique = false
            and i.indisvalid = true
            and ci.relpages > 5
        ), index_ratios as (
          select
            i.indexrelid as index_id,
            i.schema_name,
            i.table_name,
            i.index_name,
            idx_scan,
            all_scans,
            round(( case when all_scans = 0 then 0.0::numeric
              else idx_scan::numeric/all_scans * 100 end), 2) as index_scan_pct,
            writes,
            round((case when writes = 0 then idx_scan::numeric else idx_scan::numeric/writes end), 2)
              as scans_per_write,
            index_bytes as index_size_bytes,
            table_size as table_size_bytes,
            i.relpages,
            idx_is_btree,
            i.opclasses,
            (
              select count(1)
              from fk_indexes fi
              where fi.fk_table_ref = i.table_name
                and fi.schema_name = i.schema_name
                and fi.opclasses like (i.opclasses || '%')
            ) > 0 as supports_fk
          from indexes i
          join table_scans ts on ts.relid = i.indrelid
        )
        select
          tag_reason,
          index_id,
            schema_name AS tag_schema_name,
            table_name AS tag_table_name,
            index_name AS tag_index_name,
            idx_scan,
            all_scans,
            index_scan_pct,
            writes,
            scans_per_write,
            index_size_bytes,
            table_size_bytes,
            relpages,
            idx_is_btree,
            opclasses AS tag_opclasses,
            supports_fk,
            grp
        from (
          select
            'Low Scans, High Writes' as tag_reason,
            *,
            1 as grp
          from index_ratios
          where
              scans_per_write <= 1
              and index_scan_pct < 10
              and idx_scan > 0
              and writes > 100
              and idx_is_btree
          union all
          select
            'Seldom Used Large Indexes' as tag_reason,
            *,
            2 as grp
          from index_ratios
          where
              index_scan_pct < 5
              and scans_per_write > 1
              and idx_scan > 0
              and idx_is_btree
              and index_size_bytes > 100000000
          union all
          select
            'High-Write Large Non-Btree' as tag_reason,
            index_ratios.*,
            3 as grp
          from index_ratios, all_writes
          where
              ( writes::numeric / ( total_writes + 1 ) ) > 0.02
              and not idx_is_btree
              and index_size_bytes > 100000000
        ) t
        order by grp, index_size_bytes desc;
    gauges:
      - '*'
    statement_timeout_seconds: 15
  stats_reset:
    description: >
      This metric tracks when statistics were last reset at the database level.
      It provides visibility into the freshness of statistics data, which is essential for understanding
      the reliability of usage metrics. A recent reset time indicates that usage statistics
      may not reflect long-term patterns. Note that Postgres tracks stats resets at the database level,
      not per-index or per-table.
    sqls:
      11: |
        select
          datname as tag_database_name,
          extract(epoch from stats_reset)::int as stats_reset_epoch,
          extract(epoch from now() - stats_reset)::int as seconds_since_reset
        from pg_stat_database
        where datname = current_database()
          and stats_reset is not null;
    gauges:
      - 'stats_reset_epoch'
      - 'seconds_since_reset'
    statement_timeout_seconds: 15
  archive_lag:
    description: >
      This metric measures the lag in WAL archive processing.
      It provides insights into the time taken to archive WAL logs and the current status of the archive process.
      This metric helps administrators monitor the WAL archive process and identify any performance issues.
    sqls:
      11: |
        -- postgresql wal archiving lag monitor
        with wal_info as (
            select
                last_archived_wal,
                last_archived_time,
                substr(last_archived_wal, 9, 8) as log_id_hex,
                ('x' || substr(last_archived_wal, 17, 8))::bit(32)::bigint as segment_dec,
                archived_count,
                failed_count,
                -- wal_segment_size is already in bytes!
                (select setting::bigint 
                from pg_settings 
                where name = 'wal_segment_size') as wal_segment_size_bytes
            from pg_stat_archiver
            where last_archived_wal is not null
        )
        select 
            pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::bigint as current_lsn_numeric,
            pg_wal_lsn_diff((log_id_hex || '/' || lpad(to_hex((segment_dec + 1) * wal_segment_size_bytes), 8, '0'))::pg_lsn, '0/0')::bigint as archived_wal_finish_lsn_numeric,
            
            round(
                pg_wal_lsn_diff(
                    pg_current_wal_lsn(),
                    (log_id_hex || '/' || lpad(to_hex(segment_dec * wal_segment_size_bytes), 8, '0'))::pg_lsn
                )::numeric / wal_segment_size_bytes, 
                2
            ) as wal_files_behind,
            
            pg_size_pretty(wal_segment_size_bytes) as wal_segment_size,
            extract(epoch from (now() - last_archived_time))::int as seconds_since_archive,
            
            -- alert thresholds based on segment size
            case 
                when pg_wal_lsn_diff(
                        pg_current_wal_lsn(), 
                        (log_id_hex || '/' || lpad(to_hex(segment_dec * wal_segment_size_bytes), 8, '0'))::pg_lsn
                    ) > 6 * wal_segment_size_bytes then 'critical'
                when pg_wal_lsn_diff(
                        pg_current_wal_lsn(), 
                        (log_id_hex || '/' || lpad(to_hex(segment_dec * wal_segment_size_bytes), 8, '0'))::pg_lsn
                    ) > 3 * wal_segment_size_bytes then 'warning'
                else 'ok'
            end as tag_status,
            
            archived_count,
            failed_count
        from wal_info;
    gauges:
      - 'seconds_since_archive'
      - 'archived_count'
      - 'failed_count'
      - 'wal_files_behind'
      - 'current_lsn_numeric'
      - 'archived_wal_start_lsn_numeric'
    statement_timeout_seconds: 15
  pg_vacuum_progress:
    sqls:
      11: |
        select
          current_database() AS tag_datname,
          N.nspname as tag_schema_name,
          c.relname as tag_table_name,
          N.nspname || '.' || c.relname as tag_relname,
          s.relid AS tag_relid,
          case when A.query ~ '^autovacuum.*(to prevent wraparound)' then
            'aggressive_autovacuum'
          when A.query ~ '^autovacuum' then
            'autovacuum'
          when A.query ~* '^vacuum' then
            'manual_vacuum'
          else
            'unknown'
          end as tag_vacuum_mode,
          extract(epoch from A.query_start) as query_start,
          case when S.phase ~ 'initial' then
            1
          when S.phase ~ 'scanning heap' then 
            2
          WHEN S.phase ~ 'vacuuming indexes' THEN
            3
          WHEN S.phase ~ 'vacuuming heap' THEN
            4
          WHEN S.phase ~ 'cleaning up indexes' THEN
            5
          WHEN S.phase ~ 'truncating heap' THEN
            6
          WHEN S.phase ~ 'final cleanup' THEN
            7
          end tag_phase,
          S.heap_blks_total::float,
          S.heap_blks_scanned::float,
          S.heap_blks_vacuumed::float,
          S.index_vacuum_count::float,
          (S.max_dead_tuples / 1024 / 1024)::float as max_dead_tuples_mb,
          S.num_dead_tuples::float as num_dead_item_ids
        from
          pg_stat_progress_vacuum as S
          join pg_database D on (S.datid = D.oid)
          join pg_stat_activity as A on (S.pid = A.pid)
          join pg_class C on (C.oid = S.relid)
          join pg_namespace N on (N.oid = C.relnamespace)
      17: |
        select
          current_database() AS tag_datname,
          N.nspname as tag_schema_name,
          c.relname as tag_table_name,
          N.nspname || '.' || c.relname as tag_relname,
          s.relid AS tag_relid,
          case when A.query ~ '^autovacuum.*(to prevent wraparound)' then
            'aggressive_autovacuum'
          when A.query ~ '^autovacuum' then
            'autovacuum'
          when A.query ~* '^vacuum' then
            'manual_vacuum'
          else
            'unknown'
          end as tag_vacuum_mode,
          extract(epoch from A.query_start) as query_start,
          case when S.phase ~ 'initial' then
            1
          when S.phase ~ 'scanning heap' then 
            2
          WHEN S.phase ~ 'vacuuming indexes' THEN
            3
          WHEN S.phase ~ 'vacuuming heap' THEN
            4
          WHEN S.phase ~ 'cleaning up indexes' THEN
            5
          WHEN S.phase ~ 'truncating heap' THEN
            6
          WHEN S.phase ~ 'final cleanup' THEN
            7
          end tag_phase,
          S.heap_blks_total::float,
          S.heap_blks_scanned::float,
          S.heap_blks_vacuumed::float,
          S.index_vacuum_count::float,
          (S.max_dead_tuple_bytes / 1024 / 1024)::float as max_dead_tuples_mb,
          S.num_dead_item_ids::float
        from
          pg_stat_progress_vacuum as S
          join pg_database D on (S.datid = D.oid)
          join pg_stat_activity as A on (S.pid = A.pid)
          join pg_class C on (C.oid = S.relid)
          join pg_namespace N on (N.oid = C.relnamespace)
    gauges:
      - '*'
    statement_timeout_seconds: 15
  pg_index_pilot:
    sqls:
      11: |
        select
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          datname as tag_datname,
          schemaname as tag_schemaname,
          relname as tag_relname,
          indexrelname as tag_indexrelname,
          indexsize as index_size_bytes,
          indisvalid::int as is_valid,
          estimated_tuples,
          best_ratio
        from index_pilot.index_latest_state
        order by indexsize desc
        limit 2000;
    gauges:
      - index_size_bytes
      - is_valid
      - estimated_tuples
      - best_ratio
    statement_timeout_seconds: 15
  pg_index_pilot_config:
    sqls:
      12: |
        select
          coalesce(datname, '*') as tag_datname,
          coalesce(schemaname, '*') as tag_schemaname,
          coalesce(relname, '*') as tag_relname,
          coalesce(indexrelname, '*') as tag_indexrelname,
          key as tag_config_key,
          case 
            when key = 'index_size_threshold' then 
              case 
                when value ~ '^[0-9]+MB$' then (regexp_replace(value, 'MB$', '')::numeric * 1024 * 1024)::float
                when value ~ '^[0-9]+kB$' then (regexp_replace(value, 'kB$', '')::numeric * 1024)::float
                when value ~ '^[0-9]+GB$' then (regexp_replace(value, 'GB$', '')::numeric * 1024 * 1024 * 1024)::float
                else 0
              end
            when key = 'minimum_reliable_index_size' then 
              case 
                when value ~ '^[0-9]+kB$' then (regexp_replace(value, 'kB$', '')::numeric * 1024)::float
                when value ~ '^[0-9]+MB$' then (regexp_replace(value, 'MB$', '')::numeric * 1024 * 1024)::float
                else 0
              end
            when key = 'index_rebuild_scale_factor' then value::float
            when key = 'reindex_history_retention_period' then 
              case when value ~ 'years?' then regexp_replace(value, ' years?', '')::int else 0 end
            when key = 'skip' then case when value::boolean then 1 else 0 end
            else 0
          end as config_value_normalized,
          value as tag_config_value_raw
        from index_pilot.config
        order by id;
    gauges:
      - config_value_normalized
    statement_timeout_seconds: 15
  pg_statio_all_tables:
    description: >
      Retrieves table-level I/O statistics from the PostgreSQL `pg_statio_all_tables` view, providing insights into I/O operations for all tables.
      It returns block-level read and hit statistics for heap, index, TOAST, and TOAST index operations broken down by schema and table.
      Joined with pg_class for efficient ordering by table size.
      This metric helps administrators monitor table-level I/O performance and identify which tables are generating the most I/O activity.
      Compatible with all PostgreSQL versions.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          s.schemaname as tag_schemaname,
          s.relname as tag_relname,
          s.heap_blks_read,
          s.heap_blks_hit,
          s.idx_blks_read,
          s.idx_blks_hit,
          s.toast_blks_read,
          s.toast_blks_hit,
          s.tidx_blks_read,
          s.tidx_blks_hit
        from
          pg_statio_all_tables as s
          join pg_class as c on
            s.relname = c.relname
            and s.schemaname = c.relnamespace::regnamespace::name
        order by c.relpages desc
        limit 5000;
    gauges:
      - '*'
    statement_timeout_seconds: 15
  pg_statio_all_indexes:
    description: >
      Retrieves index-level I/O statistics from the PostgreSQL `pg_statio_all_indexes` view, providing insights into I/O operations for all indexes.
      It returns block-level read and hit statistics for index operations broken down by schema, table, and index name.
      Joined with pg_class for efficient ordering by index size.
      This metric helps administrators monitor index-level I/O performance and identify which indexes are generating the most I/O activity.
      Compatible with all PostgreSQL versions.
    sqls:
      11: |-
        select /* pgwatch_generated */
          (extract(epoch from now()) * 1e9)::int8 as epoch_ns,
          current_database() as tag_datname,
          s.schemaname as tag_schemaname,
          s.relname as tag_relname,
          s.indexrelname as tag_indexrelname,
          s.idx_blks_read,
          s.idx_blks_hit
        from
          pg_statio_all_indexes as s
          join pg_class as c on
            s.indexrelname = c.relname
            and s.schemaname = c.relnamespace::regnamespace::name
        order by c.relpages desc
        limit 5000;
    gauges:
      - '*'
    statement_timeout_seconds: 15
  
  multixact_size:
    sqls:
      11: |
        with env as (
          select
            exists (
              select
              from pg_proc p
              join pg_namespace n on n.oid = p.pronamespace
              where p.proname = 'pg_ls_multixactdir' and n.nspname = 'rds_tools'
            ) as has_rds_fn,
            exists (select from pg_proc where proname = 'pg_ls_dir')    as has_pg_ls_dir_func,
            exists (select from pg_proc where proname = 'pg_stat_file') as has_pg_stat_file_func
        ),
        can_local as (
          select (has_pg_ls_dir_func and has_pg_stat_file_func) as ok from env
        ),
        -- Use query_to_xml to safely execute RDS-specific multixact directory listing query.
        -- The XML wrapper allows the query to fail gracefully if rds_tools.pg_ls_multixactdir()
        -- is unavailable or returns errors, preventing the entire metric from failing.
        rds_probe_xml as (
          select query_to_xml($q$
            with files as (
              select name, size
              from rds_tools.pg_ls_multixactdir()
            ),
            members as (
              select sum(size)::bigint as sz from files where name like 'pg_multixact/members%'
            ),
            offsets as (
              select sum(size)::bigint as sz from files where name like 'pg_multixact/offsets%'
            ),
            has_rows as (
              select exists(select 1 from files where name like 'pg_multixact/%') as any_rows
            )
            select
              case when (select any_rows from has_rows) then coalesce((select sz from members), 0) end as members_bytes,
              case when (select any_rows from has_rows) then coalesce((select sz from offsets), 0) end as offsets_bytes,
              case when (select any_rows from has_rows) then 0 else 1 end as status_code
          $q$, true, true, '') as x
          where (select has_rds_fn from env)
        ),
        -- Use query_to_xml to safely execute standard Postgres multixact directory listing query.
        -- The XML wrapper allows the query to fail gracefully if pg_stat_file() or pg_ls_dir()
        -- are unavailable or return permission errors, preventing the entire metric from failing.
        local_probe_xml as (
          select query_to_xml($q$
            with dirs as (
              select
                (pg_stat_file('pg_multixact/members', true)).isdir as has_members,
                (pg_stat_file('pg_multixact/offsets', true)).isdir as has_offsets
            ),
            flags as (
              select ((select has_members from dirs) or (select has_offsets from dirs)) as has_any
            ),
            members as (
              select sum((pg_stat_file(format('pg_multixact/members/%s', d), true)).size)::bigint as sz
              from pg_ls_dir('pg_multixact/members') as d(d)
              where (select has_members from dirs)
            ),
            offsets as (
              select sum((pg_stat_file(format('pg_multixact/offsets/%s', d), true)).size)::bigint as sz
              from pg_ls_dir('pg_multixact/offsets') as d(d)
              where (select has_offsets from dirs)
            )
            select
              case when (select has_any from flags) then coalesce((select sz from members), 0) end as members_bytes,
              case when (select has_any from flags) then coalesce((select sz from offsets), 0) end as offsets_bytes,
              case when (select has_any from flags) then 0 else 1 end as status_code
          $q$, true, true, '') as x
          where not (select has_rds_fn from env) and (select ok from can_local)
        ),
        picked as (
          select * from rds_probe_xml
          union all
          select * from local_probe_xml
          limit 1
        ),
        parsed as (
          select
            (xpath('//members_bytes/text()',         x))[1]::text::bigint as members_bytes,
            (xpath('//offsets_bytes/text()',         x))[1]::text::bigint as offsets_bytes,
            (xpath('//status_code/text()',           x))[1]::text::int    as status_code
          from picked
        )
        select * from parsed
        union all
        select
          null::bigint as members_bytes,
          null::bigint as offsets_bytes,
          2::int       as status_code
        where not exists (select 1 from parsed);
    gauges:
      - members_bytes
      - offsets_bytes
      - status_code
    statement_timeout_seconds: 15

presets:
  full:
    description: almost all available metrics for a even deeper performance understanding
    metrics:
      bgwriter: 30
      checkpointer: 30
      db_size: 30
      db_stats: 30
      locks_mode: 30
      replication: 30
      replication_slots: 30
      settings: 300
      table_stats: 30
      wait_events: 15
      wal: 30
      pg_stat_activity: 15
      pg_stat_wal_receiver: 30
      pg_archiver: 30
      pg_stat_all_tables: 30
      pg_class: 30
      pg_stat_all_indexes: 30
      pg_stat_statements: 30
      pg_stat_replication: 30
      pg_stat_slru: 30
      pg_statio_all_tables: 30
      pg_statio_all_indexes: 30
      pg_total_relation_size: 30
      pg_blocked: 30
      pg_long_running_transactions: 30
      pg_stuck_idle_in_transaction: 30
      pg_txid: 30
      pg_database_wraparound: 30
      pg_xlog_position: 30
      pg_table_bloat: 7200
      table_size_detailed: 30
      pg_btree_bloat: 7200
      pg_invalid_indexes: 7200
      redundant_indexes: 10800
      unused_indexes: 7200
      rarely_used_indexes: 10800
      stats_reset: 3600
      archive_lag: 15
      pg_vacuum_progress: 30
      multixact_size: 300
  pg_index_pilot:
    metrics:
      pg_index_pilot: 30
      pg_index_pilot_config: 7200