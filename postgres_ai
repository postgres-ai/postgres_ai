#!/bin/bash

# Postgres AI CLI
# A CLI tool for managing the PostgreSQL monitoring system with Docker Compose

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_NAME="postgres-ai-mon"
COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
PYTHON_REQUIREMENTS="$SCRIPT_DIR/requirements.txt"
INSTANCES_FILE="$SCRIPT_DIR/instances.yml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Print banner
print_banner() {
    echo -e "${BLUE}"
    echo "=================================="
    echo "  Postgres AI CLI"
    echo "=================================="
    echo -e "${NC}"
}

# Show help
show_help() {
    print_banner
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo
    echo "COMMANDS:"
    echo "  quickstart [--demo] [--api-key=KEY] [--db-url=URL] [-y] Complete setup: install, configure, and start monitoring"
    echo "  install [--demo]    Clone repository and setup the monitoring project"
    echo "  start               Start all monitoring services using Docker Compose (auto-generates secure Grafana password)"
    echo "  stop                Stop all services"
    echo "  restart             Restart all services"
    echo "  status              Show status of all services"
    echo "  logs [SERVICE]      Show logs for all services or specific service"
    echo "  health              Check health of all services"
    echo "  config              Show current configuration"
    echo "  update-config       Update configuration files"
    echo "  reset               Stop services and remove all data"
    echo "  reset <service>     Stop specific service, remove its volume, and restart it"
    echo "  clean               Clean up temporary files and unused Docker resources"
    echo "  shell [SERVICE]     Open shell in specified service container"
    echo "  check               Verify system prerequisites and readiness"
    echo ""
    echo "INSTANCE MANAGEMENT:"
    echo "  list-instances                    List all configured PostgreSQL instances"
    echo "  add-instance [CONN_STR] [NAME]    Add a new PostgreSQL instance for monitoring"
    echo "  remove-instance <NAME>            Remove a PostgreSQL instance"
    echo "  test-instance <NAME>              Test connection to a PostgreSQL instance"
    echo ""
    echo "API KEY MANAGEMENT:"
    echo "  add-key <api_key>              Add Postgres AI API key for report uploads"
    echo "  show-key                       Show current API key (masked)"
    echo "  remove-key                     Remove stored API key"
    echo ""
    echo "GRAFANA PASSWORD MANAGEMENT:"
    echo "  generate-grafana-password      Generate secure password for Grafana"
    echo "  show-grafana-credentials       Show current Grafana credentials"
    echo ""
    echo "OPTIONS:"
    echo "  --demo                         Include demo PostgreSQL database for testing"
    echo "  --api-key=KEY                  Provide API key for automated report uploads"
    echo "  --db-url=URL                   Provide PostgreSQL connection URL for monitoring"
    echo "  -y, --yes                      Accept all defaults and skip interactive prompts"
    echo ""
    echo "RESTRICTIONS:"
    echo "  --demo and --api-key cannot be used together (demo mode is for testing only)"
    echo ""
    echo "  help                Show this help message"
    echo
    echo "EXAMPLES:"
    echo "  $0 quickstart                              # Complete setup for production (install + configure + start)"
    echo "  $0 quickstart --demo                       # Complete setup with demo database included"
    echo "  $0 quickstart -y                           # Complete setup with auto-yes (accept all defaults)"
    echo "  $0 quickstart --api-key=your_api_key       # Complete setup with API key for automated reports"
    echo "  $0 quickstart --db-url=postgresql://user:pass@host:5432/db  # Complete setup with database URL"
    echo "  $0 quickstart --demo                       # Demo mode (testing only, no API key)"
    echo "  $0 quickstart --db-url=postgresql://user:pass@host:5432/db --api-key=key  # Complete with both"
    echo "  $0 quickstart -y --api-key=key --db-url=postgresql://user:pass@host:5432/db  # Fully automated setup"
    echo "  $0 install                   # Clone repository and setup for production"
    echo "  $0 install --demo           # Clone repository and setup with demo database"
    echo "  $0 start                     # Start monitoring services (auto-generates secure Grafana password)"
    echo "  $0 logs pgwatch-postgres     # Show logs for postgres pgwatch instance"
    echo "  $0 health                    # Check if all services are healthy"
    echo "  $0 shell target-db           # Open shell in target database (demo mode only)"
    echo "  $0 reset sink-postgres       # Reset PostgreSQL sink (deletes all postgres metrics data and restarts)"
    echo "  $0 check                     # Verify system prerequisites and readiness"
    echo "  $0 generate-grafana-password # Generate secure password for Grafana"
    echo "  $0 show-grafana-credentials  # Show current Grafana login credentials"
    echo ""
    echo "INSTANCE MANAGEMENT EXAMPLES:"
    echo "  $0 list-instances            # Show all configured instances"
    echo "  $0 add-instance              # Interactively add a new PostgreSQL instance"
    echo "  $0 test-instance prod-db     # Test connection to 'prod-db' instance"
    echo "  $0 remove-instance old-db    # Remove 'old-db' instance"
    echo ""
    echo "WORKFLOW:"
    echo "  QUICKSTART (RECOMMENDED):"
    echo "    • Run '$0 quickstart' for complete production setup (install + configure + start)"
    echo "    • Run '$0 quickstart --demo' for demo mode with sample database"
    echo "    • Add '--api-key=your_key' to any quickstart command for automated report uploads"
    echo "    • Add '--db-url=postgresql://user:pass@host:port/db' to automatically configure a database"
    echo "    • Add '-y' to accept all defaults and skip interactive prompts (useful for automation)"
    echo "    • Secure Grafana password is automatically generated for all setups"
    echo ""
    echo "  MANUAL SETUP:"
    echo "    PRODUCTION MODE:"
    echo "      1. Run '$0 install' to setup monitoring infrastructure"
    echo "      2. Add your PostgreSQL instances: '$0 add-instance postgresql://user:pass@host:port/db'"
    echo "      3. Start monitoring: '$0 start' (auto-generates secure Grafana password)"
    echo ""
    echo "    DEMO MODE:"
    echo "      1. Run '$0 install --demo' to setup with demo database included"
    echo "      2. Start all services: '$0 start' (auto-generates secure Grafana password)"
    echo "      3. Access demo database at localhost:55432"
    echo ""
    echo "  The CLI auto-detects the project directory and should be run from outside it"
    echo
    echo "SERVICES:"
    echo "  sink-postgres       PostgreSQL sink for storing metrics"
    echo "  sink-prometheus     Prometheus sink for storing metrics"
    echo "  pgwatch-postgres    PGWatch instance with PostgreSQL sink"
    echo "  pgwatch-prometheus  PGWatch instance with Prometheus sink"
    echo "  grafana             Grafana dashboard interface"
    echo "  flask-pgss-api      Flask API backend"
    echo "  postgres-reports    PostgreSQL reports generator (runs every 24h)"
    echo "  target-db           Demo PostgreSQL database (--demo mode only)"
    echo "  cadvisor            Container resource monitoring (auto-started)"
    echo "  node-exporter       System resource monitoring (auto-started)"
    echo "  postgres-exporter   Database sink monitoring (auto-started)"
    echo
    echo "ACCESS URLS:"
    echo "  🚀 MAIN: Grafana Dashboard: http://localhost:3000 (demouser/demopwd)"
    echo ""
    echo "  Technical URLs (for advanced users):"
    echo "    PGWatch Postgres:  http://localhost:58080"
    echo "    PGWatch Prometheus: http://localhost:58089"
    echo "    Prometheus:        http://localhost:59090"
    echo "    Flask API:         http://localhost:55000"
    echo "    Sink DB:           postgresql://postgres:postgres@localhost:55433/postgres"
    echo "    Demo DB:           postgresql://postgres:postgres@localhost:55432/target_database (--demo mode only)"
}

# Check basic prerequisites (software installation)
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    local missing_deps=()
    
    # Check Git
    if ! command -v git &> /dev/null; then
        missing_deps+=("git")
    fi
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        missing_deps+=("docker")
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
        missing_deps+=("docker-compose")
    fi
    
    # Check curl for health checks
    if ! command -v curl &> /dev/null; then
        missing_deps+=("curl")
    fi
    
    # Future: Check Python when reports functionality is added
    # if ! command -v python3 &> /dev/null; then
    #     missing_deps+=("python3")
    # fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        echo
        echo "Please install the missing dependencies:"
        echo "  macOS: brew install git docker docker-compose curl"
        echo "  Ubuntu/Debian: apt-get install git docker.io docker-compose curl"
        echo "  CentOS/RHEL: yum install git docker docker-compose curl"
        exit 1
    fi
    
    log_success "All prerequisites are installed"
}

# Check if Docker daemon is running
check_docker_running() {
    log_info "Checking Docker daemon status..."
    
    if ! docker info &> /dev/null; then
        log_error "Cannot access Docker daemon"
        echo
        echo "This could be due to:"
        echo "  1. Docker daemon not running"
        echo "  2. User lacks permission to access Docker"
        echo
        echo "Solutions:"
        echo "  If Docker daemon is not running:"
        echo "    • macOS: Start Docker Desktop application"
        echo "    • Linux: sudo systemctl start docker"
        echo "    • Windows: Start Docker Desktop application"
        echo
        echo "  If permission denied:"
        echo "    • Linux: Add user to docker group: sudo usermod -aG docker \$USER"
        echo "    • Then log out and back in, or run: newgrp docker"
        echo "    • Verify with: docker run hello-world"
        echo
        echo "  Alternative: Run postgres_ai with sudo (not recommended)"
        exit 1
    fi
    
    log_success "Docker daemon is accessible"
}

# Check system resources
check_system_resources() {
    log_info "Checking system resources..."
    
    # Check available disk space (need at least 2GB)
    local available_space
    if command -v df &> /dev/null; then
        available_space=$(df "$SCRIPT_DIR" | awk 'NR==2 {print $4}')
        local min_space_kb=$((2 * 1024 * 1024)) # 2GB in KB
        
        if [ "$available_space" -lt "$min_space_kb" ]; then
            log_warning "Low disk space detected. Available: $((available_space / 1024))MB, Recommended: 2GB+"
        fi
    fi
    
    # Check if required ports are available
    local required_ports=(3000 55000 55432 55433 58080 58089 59090)
    local ports_in_use=()
    
    for port in "${required_ports[@]}"; do
        if command -v lsof &> /dev/null; then
            if lsof -i ":$port" &> /dev/null; then
                ports_in_use+=("$port")
            fi
        elif command -v netstat &> /dev/null; then
            if netstat -ln | grep ":$port " &> /dev/null; then
                ports_in_use+=("$port")
            fi
        fi
    done
    
    if [ ${#ports_in_use[@]} -ne 0 ]; then
        log_warning "The following ports are already in use: ${ports_in_use[*]}"
        log_warning "This may cause conflicts when starting services"
        echo "Required ports: 3000 (Grafana), 55000 (Flask), 55432 (Target DB), 55433 (Sink DB),"
        echo "               58080 (PGWatch), 58089 (PGWatch Prometheus), 59090 (Prometheus)"
    fi
    
    log_success "System resources check completed"
}

# Check if project is properly initialized
check_project_setup() {
    if ! detect_project_dir; then
        log_error "Project files not found in current directory"
        log_info "Please run one of the following:"
        echo "  • $0 quickstart    # Complete setup (recommended)"
        echo "  • $0 install       # Setup project only"
        exit 1
    fi
    
    # Check if essential files exist
    local required_files=("docker-compose.yml" "instances.yml")
    local missing_files=()
    
    for file in "${required_files[@]}"; do
        if [ ! -f "$SCRIPT_DIR/$file" ]; then
            missing_files+=("$file")
        fi
    done
    
    if [ ${#missing_files[@]} -ne 0 ]; then
        log_error "Missing required files: ${missing_files[*]}"
        log_info "Please run: $0 install"
        exit 1
    fi
}

# Check if services are running (for commands that require them)
check_services_running() {
    log_info "Checking if monitoring services are running..."
    
    local compose_cmd=$(get_compose_cmd)
    cd "$SCRIPT_DIR"
    
    # Get list of running containers
    local running_services
    running_services=$($compose_cmd -f "$COMPOSE_FILE" ps --services --filter "status=running" 2>/dev/null)
    
    if [ -z "$running_services" ]; then
        log_error "No monitoring services are currently running"
        log_info "Please start services first: $0 start"
        exit 1
    fi
    
    log_success "Monitoring services are running"
}

# Clean up any existing containers that might conflict
cleanup_existing_containers() {
    log_info "Checking for existing containers that might conflict..."
    
    # List of container names that might conflict
    local container_names=(
        "sink-postgres"
        "sink-prometheus" 
        "pgwatch-postgres"
        "pgwatch-prometheus"
        "grafana"
        "flask-pgss-api"
        "target-db"
        "postgres-reports"
        "sources-generator"
    )
    
    # Check for containers matching our service names
    local existing_containers=""
    
    for container_name in "${container_names[@]}"; do
        local found_containers
        found_containers=$(docker ps -a --filter "name=$container_name" --format "{{.Names}}" 2>/dev/null || true)
        if [ -n "$found_containers" ]; then
            if [ -n "$existing_containers" ]; then
                existing_containers="$existing_containers"$'\n'"$found_containers"
            else
                existing_containers="$found_containers"
            fi
        fi
    done
    
    if [ -n "$existing_containers" ]; then
        log_warning "Found existing containers from previous installations:"
        echo "$existing_containers" | sed 's/^/  • /'
        echo
        log_warning "These containers may conflict with the new installation."
        log_warning "Removing them will stop any running services and delete their data."
        echo
        
        read -p "Are you sure you want to remove these existing containers? (Y/n): " -n 1 -r
        echo
        
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            log_info "Stopping and removing existing containers..."
            
            # Stop containers first
            echo "$existing_containers" | xargs -r docker stop 2>/dev/null || true
            
            # Remove containers
            echo "$existing_containers" | xargs -r docker rm 2>/dev/null || true
            
            # Remove any orphaned volumes
            docker volume prune -f 2>/dev/null || true
            
            log_success "Existing containers removed"
        else
            log_warning "Keeping existing containers - this may cause conflicts during installation"
            log_info "If you encounter issues, run '$0 reset' to clean up manually"
        fi
    else
        log_success "No conflicting containers found"
    fi
}

# Comprehensive precheck for installation commands
precheck_for_install() {
    check_prerequisites
    check_docker_running
    check_system_resources
    cleanup_existing_containers
}

# Precheck for service management commands
precheck_for_services() {
    check_prerequisites
    check_docker_running
    check_project_setup
}

# Precheck for commands that need running services
precheck_for_running_services() {
    check_prerequisites
    check_docker_running
    check_project_setup
    check_services_running
}

# System readiness check command
system_check() {
    print_banner
    log_info "Performing comprehensive system check..."
    echo
    
    # Basic prerequisites
    check_prerequisites
    check_docker_running
    check_system_resources
    
    # Project setup (optional)
    echo
    log_info "Checking project setup..."
    if detect_project_dir; then
        log_success "Project files found in: $SCRIPT_DIR"
        check_project_setup
        
        # Check if services are running (optional)
        echo
        log_info "Checking service status..."
        local compose_cmd=$(get_compose_cmd)
        cd "$SCRIPT_DIR"
        
        local running_services
        running_services=$($compose_cmd -f "$COMPOSE_FILE" ps --services --filter "status=running" 2>/dev/null)
        
        if [ -n "$running_services" ]; then
            log_success "Services are running:"
            echo "$running_services" | sed 's/^/  ✅ /'
        else
            log_info "No services are currently running"
            log_info "Use '$0 start' to start monitoring services"
        fi
        
        # Show API key status
        echo
        log_info "API key configuration:"
        if [ -f "$SCRIPT_DIR/.pgwatch-config" ] && grep -q "^api_key=" "$SCRIPT_DIR/.pgwatch-config"; then
            local api_key=$(grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
            local masked_key="${api_key:0:4}$( printf '%*s' $((${#api_key} - 8)) '' | tr ' ' '*' )${api_key: -4}"
            log_success "API key configured: $masked_key"
        else
            log_info "No API key configured (reports will be local only)"
        fi
        
    else
        log_warning "Project not found in current directory"
        log_info "Run '$0 quickstart' to set up the monitoring system"
    fi
    
    echo
    log_success "System check completed!"
}

# Check if demo mode is enabled
is_demo_mode() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        if grep -q "demo_mode=true" "$SCRIPT_DIR/.pgwatch-config"; then
            return 0
        else
            return 1
        fi
    fi
    # Default to false if config file doesn't exist
    return 1
}

# Password Generator Functions

# Generate a secure random password
generate_secure_password() {
    # Generate a 16-character password with mixed case, numbers, and special characters
    local password
    password=$(openssl rand -base64 12 | tr -d "=+/" | cut -c1-16)
    
    # Ensure it contains at least one uppercase, one lowercase, one number, and one special character
    local upper=$(echo {A..Z} | tr -d ' ' | fold -w1 | sort -R | head -1)
    local lower=$(echo {a..z} | tr -d ' ' | fold -w1 | sort -R | head -1)
    local number=$(echo {0..9} | tr -d ' ' | fold -w1 | sort -R | head -1)
    local special=$(echo "!@#$%^&*" | fold -w1 | sort -R | head -1)
    
    # Replace characters at random positions
    local pos1=$((RANDOM % 16))
    local pos2=$((RANDOM % 16))
    local pos3=$((RANDOM % 16))
    local pos4=$((RANDOM % 16))
    
    # Ensure all positions are different
    while [ "$pos2" -eq "$pos1" ]; do pos2=$((RANDOM % 16)); done
    while [ "$pos3" -eq "$pos1" ] || [ "$pos3" -eq "$pos2" ]; do pos3=$((RANDOM % 16)); done
    while [ "$pos4" -eq "$pos1" ] || [ "$pos4" -eq "$pos2" ] || [ "$pos4" -eq "$pos3" ]; do pos4=$((RANDOM % 16)); done
    
    # Build the final password
    password=$(echo "$password" | sed "s/./$upper/$((pos1+1))" | sed "s/./$lower/$((pos2+1))" | sed "s/./$number/$((pos3+1))" | sed "s/./$special/$((pos4+1))")
    
    echo "$password"
}

# Check if Grafana password exists
check_grafana_password_exists() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        local password=$(grep "^grafana_password=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$password" ]; then
            return 0  # Password exists
        fi
    fi
    return 1  # Password doesn't exist
}

# Ensure Grafana password exists (generate if needed)
ensure_grafana_password() {
    if ! check_grafana_password_exists; then
        log_info "No Grafana password configured - generating secure password..."
        generate_grafana_password
    else
        log_info "Grafana password already configured"
    fi
}

# Generate Grafana password and update configuration
generate_grafana_password() {
    local password
    password=$(generate_secure_password)
    
    # Create config file if it doesn't exist
    touch "$SCRIPT_DIR/.pgwatch-config"
    
    # Remove existing grafana_password line if present
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep -v "^grafana_password=" "$SCRIPT_DIR/.pgwatch-config" > "$SCRIPT_DIR/.pgwatch-config.tmp" || true
        mv "$SCRIPT_DIR/.pgwatch-config.tmp" "$SCRIPT_DIR/.pgwatch-config"
    fi
    
    # Add the new Grafana password
    echo "grafana_password=$password" >> "$SCRIPT_DIR/.pgwatch-config"
    
    log_success "Grafana password generated successfully"
    log_info "New password: $password"
    log_info "Username: monitor"
    log_info "Access Grafana at: http://localhost:3000"
    
    # Change password via existing Grafana container
    change_grafana_password_via_container "$password"
    
    return 0
}

# Change Grafana password via existing container
change_grafana_password_via_container() {
    local password="$1"
    local compose_cmd=$(get_compose_cmd)
    
    cd "$SCRIPT_DIR"
    
    # Check if Grafana container is running
    if ! $compose_cmd -f "$COMPOSE_FILE" ps --services --filter "status=running" | grep -q "grafana"; then
        log_warning "Grafana container is not running. Starting it first..."
        $compose_cmd -f "$COMPOSE_FILE" up -d grafana
        
        # Wait for Grafana to be ready
        log_info "Waiting for Grafana to be ready..."
        sleep 10
    fi
    
    # Change password using Grafana CLI inside the container
    log_info "Changing Grafana password via container..."
    
    # Use grafana-cli to change the admin password
    if $compose_cmd -f "$COMPOSE_FILE" exec -T grafana grafana-cli admin reset-admin-password "$password" > /dev/null 2>&1; then
        log_success "Grafana password changed successfully via container"
    else
        log_warning "Failed to change password via grafana-cli, trying alternative method..."
        
        # Alternative: Use SQL to update password directly in database
        if $compose_cmd -f "$COMPOSE_FILE" exec -T grafana sqlite3 /var/lib/grafana/grafana.db "UPDATE user SET password = '$password' WHERE login = 'monitor';" > /dev/null 2>&1; then
            log_success "Grafana password changed successfully via database update"
        else
            log_error "Failed to change Grafana password via container"
            log_info "Password has been saved to .pgwatch-config but may need manual update in Grafana"
            return 1
        fi
    fi
    
    log_info "Password saved to .pgwatch-config file"
}

# Show current Grafana credentials
show_grafana_credentials() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        local password=$(grep "^grafana_password=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$password" ]; then
            log_info "Current Grafana credentials:"
            echo "  Username: monitor"
            echo "  Password: $password"
            echo "  URL: http://localhost:3000"
        else
            log_warning "No custom Grafana password configured"
            log_info "Using default credentials: monitor/demo"
            log_info "Use '$0 generate-grafana-password' to set a secure password"
        fi
    else
        log_warning "No Grafana password configured"
        log_info "Using default credentials: monitor/demo"
        log_info "Use '$0 generate-grafana-password' to set a secure password"
    fi
}

# API Key Management Functions

# Add API key to configuration
add_api_key() {
    local api_key="$1"
    
    if [ -z "$api_key" ]; then
        log_error "Please provide an API key"
        echo "Usage: $0 add-key <api_key>"
        exit 1
    fi
    
    # Create config file if it doesn't exist
    touch "$SCRIPT_DIR/.pgwatch-config"
    
    # Remove existing api_key line if present
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep -v "^api_key=" "$SCRIPT_DIR/.pgwatch-config" > "$SCRIPT_DIR/.pgwatch-config.tmp" || true
        mv "$SCRIPT_DIR/.pgwatch-config.tmp" "$SCRIPT_DIR/.pgwatch-config"
    fi
    
    # Add the new API key
    echo "api_key=$api_key" >> "$SCRIPT_DIR/.pgwatch-config"
    
    log_success "API key added successfully"
    log_info "The API key will be used for automatic report uploads"
}

# Show API key (masked for security)
show_api_key() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        local api_key=$(grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$api_key" ]; then
            local masked_key="${api_key:0:4}$( printf '%*s' $((${#api_key} - 8)) '' | tr ' ' '*' )${api_key: -4}"
            log_info "Current API key: $masked_key"
        else
            log_warning "No API key configured"
        fi
    else
        log_warning "No API key configured"
    fi
}

# Remove API key from configuration
remove_api_key() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep -v "^api_key=" "$SCRIPT_DIR/.pgwatch-config" > "$SCRIPT_DIR/.pgwatch-config.tmp" || true
        mv "$SCRIPT_DIR/.pgwatch-config.tmp" "$SCRIPT_DIR/.pgwatch-config"
        log_success "API key removed successfully"
    else
        log_warning "No API key configured"
    fi
}

# Get API key from configuration
get_api_key() {
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2
    fi
}

# Detect project directory
detect_project_dir() {
    # Check if we're already in the project directory
    if [ -f "$SCRIPT_DIR/docker-compose.yml" ] && [ -f "$SCRIPT_DIR/instances.yml" ]; then
        return 0
    fi
    
    # Check if postgres_ai_configs directory exists in current location
    if [ -d "$SCRIPT_DIR/postgres_ai_configs" ] && [ -f "$SCRIPT_DIR/postgres_ai_configs/docker-compose.yml" ]; then
        SCRIPT_DIR="$SCRIPT_DIR/postgres_ai_configs"
        COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
        PYTHON_REQUIREMENTS="$SCRIPT_DIR/requirements.txt"
        INSTANCES_FILE="$SCRIPT_DIR/instances.yml"
        return 0
    fi
    
    # Project not found
    return 1
}

# Future: Install Python dependencies for reports
install_dependencies() {
    log_info "Skipping Python dependencies installation (only Docker monitoring for now)"
}

# Clone repository if needed
clone_repository() {
    local repo_url="https://gitlab.com/postgres-ai/postgres_ai.git"
    local project_dir="postgres_ai_configs"
    
    # Check if we're already in the project directory
    if [ -f "$SCRIPT_DIR/docker-compose.yml" ] && [ -f "$SCRIPT_DIR/instances.yml" ]; then
        log_info "Project files already exist, skipping clone"
        return 0
    fi
    
    # Check if project directory already exists
    if [ -d "$project_dir" ]; then
        log_warning "Directory '$project_dir' already exists"
        if [ "$auto_yes" = true ]; then
            log_info "Auto-yes mode: removing existing directory"
            rm -rf "$project_dir"
        else
            read -p "Remove it and clone fresh? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                rm -rf "$project_dir"
            else
                log_info "Using existing directory"
                cd "$project_dir" || exit 1
                return 0
            fi
        fi
        
    fi
    
    log_info "Cloning Postgres AI project from GitLab..."
    if git clone "$repo_url" "$project_dir"; then
        log_success "Repository cloned successfully"
        cd "$project_dir" || exit 1
        # Update SCRIPT_DIR to the cloned directory
        SCRIPT_DIR="$(pwd)"
        COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
        PYTHON_REQUIREMENTS="$SCRIPT_DIR/requirements.txt"
        INSTANCES_FILE="$SCRIPT_DIR/instances.yml"
    else
        log_error "Failed to clone repository"
        exit 1
    fi
}

# Install and setup
install_project() {
    local demo_mode=false
    
    # Check for --demo flag
    if [ "$1" = "--demo" ]; then
        demo_mode=true
        log_info "Demo mode enabled - will include target demo database"
    fi
    
    print_banner
    log_info "Setting up Postgres AI monitoring project..."
    
    # Only run full precheck if not called from quickstart (to avoid duplicate checks)
    if [ "${CALLED_FROM_QUICKSTART:-false}" != "true" ]; then
        precheck_for_install
    fi
    
    clone_repository
    install_dependencies
    
    # Create necessary directories
    mkdir -p "$SCRIPT_DIR/config/pgwatch-postgres"
    mkdir -p "$SCRIPT_DIR/config/pgwatch-prometheus"
    
    # Store demo mode setting and configure instances
    if [ "$demo_mode" = true ]; then
        echo "demo_mode=true" > "$SCRIPT_DIR/.pgwatch-config"
        log_info "Target demo database will be included for testing"
        log_info "Demo instance 'target-database' configured for monitoring"
    else
        echo "demo_mode=false" > "$SCRIPT_DIR/.pgwatch-config"
        log_info "Production mode - only monitoring infrastructure will be started"
        
        # Remove the default demo instance from instances.yml for production mode
        log_info "Removing default demo instance from configuration..."
        cat > "$INSTANCES_FILE" << 'EOF'
# PostgreSQL instances to monitor
# Add your instances using: ./postgres_ai add-instance

EOF
        log_success "Demo instance removed - instances.yml is now empty"
        log_warning "You'll need to add your own PostgreSQL instances to monitor"
    fi
    
    log_success "Setup completed!"
    log_info "Project location: $SCRIPT_DIR"
    
    if [ "$demo_mode" = true ]; then
        log_info "You can now start all services (including demo database) with: $0 start"
        log_info "The demo database will be available at: postgresql://postgres:postgres@localhost:55432/target_database"
    else
        log_info "You can now:"
        echo "  1. Add PostgreSQL instances to monitor: $0 add-instance 'postgresql://user:pass@host:port/db'"
        echo "  2. Start monitoring services: $0 start"
    fi
    

}

# Quickstart - unified setup process
quickstart_setup() {
    local demo_mode=false
    local api_key=""
    local db_url=""
    local auto_yes=false
    # Parse command line arguments
    for arg in "$@"; do
        case $arg in
            --demo)
                demo_mode=true
                ;;
            --api-key=*)
                api_key="${arg#*=}"
                ;;
            --db-url=*)
                db_url="${arg#*=}"
                ;;
            -y|--yes)
                auto_yes=true
                ;;
        esac
    done

    print_banner
    log_info "Postgres AI Monitoring - Quickstart Setup"
    log_info "This will install, configure, and start the monitoring system"
    echo
    
    # Validate conflicting options
    if [ "$demo_mode" = true ] && [ -n "$db_url" ]; then
        log_warning "Both --demo and --db-url provided. Demo mode includes its own database."
        log_warning "The --db-url will be ignored in demo mode."
        db_url=""
    fi
    
    if [ "$demo_mode" = true ] && [ -n "$api_key" ]; then
        log_error "Cannot use --api-key with --demo mode"
        log_error "Demo mode is for testing only and does not support API key integration"
        log_info "Use demo mode without API key: $0 quickstart --demo"
        log_info "Or use production mode with API key: $0 quickstart --api-key=your_key"
        exit 1
    fi
    
    # Perform comprehensive prechecks first
    log_info "Performing system prechecks..."
    precheck_for_install
    
    # Step 1: Install project
    log_info "Step 1: Installing Postgres AI monitoring project..."
    CALLED_FROM_QUICKSTART=true install_project "$1"
    
    # Step 2: Add API key (only in production mode)
    if [ "$demo_mode" = false ]; then
        echo
        log_info "Step 2: Postgres AI API Configuration (Optional)"
        log_info "An API key enables automatic upload of PostgreSQL reports to Postgres AI"
        
        if [ -n "$api_key" ]; then
            # API key provided via command line
            log_info "Using API key provided via --api-key parameter"
            add_api_key "$api_key"
        else
            # Interactive API key setup
            local proceed_with_api_key=false
            
            if [ "$auto_yes" = true ]; then
                # Auto-yes mode: proceed directly to API key entry
                log_info "Auto-yes mode: proceeding to API key setup"
                proceed_with_api_key=true
            else
                # Interactive mode: ask user
                read -p "Do you have a Postgres AI API key? (Y/n): " -n 1 -r
                echo
                
                # Default to Y if user just presses Enter or responds with Y/y
                if [[ -z $REPLY ]] || [[ $REPLY =~ ^[Yy]$ ]]; then
                    proceed_with_api_key=true
                fi
            fi
            
            if [ "$proceed_with_api_key" = true ]; then
                while true; do
                    read -p "Enter your Postgres AI API key: " input_api_key
                    if [ -n "$input_api_key" ]; then
                        # Remove any leading/trailing whitespace
                        input_api_key=$(echo "$input_api_key" | xargs)
                        if [ -n "$input_api_key" ]; then
                            add_api_key "$input_api_key"
                            break
                        fi
                    fi
                    
                    log_warning "API key cannot be empty"
                    
                    if [ "$auto_yes" = true ]; then
                        # Auto-yes mode: automatically retry
                        log_info "Auto-yes mode: retrying API key entry"
                        continue
                    else
                        # Interactive mode: ask user
                        read -p "Try again or skip API key setup, retry? (Y/n): " -n 1 -r
                        echo
                        if [[ $REPLY =~ ^[Nn]$ ]]; then
                            log_info "Skipping API key setup - reports will be generated locally only"
                            log_info "You can add an API key later with: $0 add-key <api_key>"
                            break
                        fi
                    fi
                done
            else
                log_info "Skipping API key setup - reports will be generated locally only"
                log_info "You can add an API key later with: $0 add-key <api_key>"
            fi
        fi
    else
        echo
        log_info "Step 2: Demo mode - API key configuration skipped"
        log_info "Demo mode is for testing only and does not support API key integration"
    fi
    
    # Step 3/2: Add PostgreSQL instance (if not demo mode)
    if [ "$demo_mode" = false ]; then
        echo
        log_info "Step 3: Add PostgreSQL Instance to Monitor"
        if [ -n "$db_url" ]; then
            # Database URL provided via command line
            log_info "Using database URL provided via --db-url parameter"
            log_info "Adding PostgreSQL instance from: $db_url"
            
            # Extract instance name from URL or use default
            local auto_instance_name
            if [[ "$db_url" =~ postgresql://[^@]+@([^:/]+) ]]; then
                auto_instance_name="${BASH_REMATCH[1]}"
            else
                auto_instance_name="db-instance"
            fi
            
            add_instance "$db_url" "$auto_instance_name"
            
            # Test the connection
            echo
            log_info "Testing connection to the added instance..."
            local last_instance=$(grep -E "^- name:" "$INSTANCES_FILE" | tail -1 | sed 's/^- name: //')
            if [ -n "$last_instance" ]; then
                test_instance "$last_instance"
            fi
        else
            # Interactive mode - ask user
            log_info "You need to add at least one PostgreSQL instance to monitor"
            local proceed_with_instance=false
            
            if [ "$auto_yes" = true ]; then
                # Auto-yes mode: proceed directly to instance setup
                log_info "Auto-yes mode: proceeding to add PostgreSQL instance"
                proceed_with_instance=true
            else
                # Interactive mode: ask user
                read -p "Do you want to add a PostgreSQL instance now? (Y/n): " -n 1 -r
                echo
                
                if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                    proceed_with_instance=true
                fi
            fi
            
            if [ "$proceed_with_instance" = true ]; then
                echo
                log_info "Adding PostgreSQL instance..."
                echo "You can provide either:"
                echo "  1. A full connection string: postgresql://user:pass@host:port/database"
                echo "  2. Individual connection details (interactive mode)"
                echo
                read -p "Enter connection string (or press Enter for interactive mode): " conn_str
                
                if [ -n "$conn_str" ]; then
                    # Use connection string
                    read -p "Instance name (optional, will auto-generate if empty): " instance_name
                    add_instance "$conn_str" "$instance_name"
                else
                    # Interactive mode
                    add_instance
                fi
                
                # Test the connection
                echo
                log_info "Testing connection to the added instance..."
                # Get the last added instance name
                local last_instance=$(grep -E "^- name:" "$INSTANCES_FILE" | tail -1 | sed 's/^- name: //')
                if [ -n "$last_instance" ]; then
                    test_instance "$last_instance"
                fi
            else
                log_warning "No PostgreSQL instance added - you can add one later with: $0 add-instance"
            fi
        fi
    else
        log_info "Step 2: Demo mode enabled - using included demo PostgreSQL database"
    fi
    
    # Step 4/3: Update configuration 
    echo
    if [ "$demo_mode" = true ]; then
        log_info "Step 3: Updating configuration..."
    else
        log_info "Step 4: Updating configuration..."
    fi
    update_config
    
    # Step 5/4: Ensure Grafana password is configured
    echo
    if [ "$demo_mode" = true ]; then
        log_info "Step 4: Configuring Grafana security..."
    else
        log_info "Step 5: Configuring Grafana security..."
    fi
    ensure_grafana_password
    
    # Step 6/5: Start services
    echo
    if [ "$demo_mode" = true ]; then
        log_info "Step 5: Starting monitoring services..."
    else
        log_info "Step 6: Starting monitoring services..."
    fi
    start_services
    
    # Step 7/6: Final summary
    echo
    log_success "🎉 Quickstart setup completed successfully!"
    echo
    log_info "What's running:"
    if [ "$demo_mode" = true ]; then
        echo "  ✅ Demo PostgreSQL database (monitoring target)"
    fi
    echo "  ✅ PostgreSQL monitoring infrastructure"
    echo "  ✅ Grafana dashboards (with secure password)"
    echo "  ✅ Prometheus metrics storage"
    echo "  ✅ Flask API backend"
    echo "  ✅ Automated report generation (every 24h)"
    echo "  ✅ Host stats monitoring (CPU, memory, disk, I/O)"
    echo
    
    if [ "$demo_mode" = false ]; then
        log_info "Next steps:"
        echo "  • Add more PostgreSQL instances: $0 add-instance"
        echo "  • View configured instances: $0 list-instances"
        echo "  • Check service health: $0 health"
    else
        log_info "Demo mode next steps:"
        echo "  • Explore Grafana dashboards at http://localhost:3000"
        echo "  • Connect to demo database: postgresql://postgres:postgres@localhost:55432/target_database"
        echo "  • Generate some load on the demo database to see metrics"
    fi
    
    echo
    show_access_info
}

# Get docker compose command
get_compose_cmd() {
    if command -v docker-compose &> /dev/null; then
        echo "docker-compose"
    else
        echo "docker compose"
    fi
}

# Start services
start_services() {
    precheck_for_services
    
    # Ensure Grafana password is configured before starting services
    ensure_grafana_password
    
    local compose_cmd=$(get_compose_cmd)
    
    cd "$SCRIPT_DIR"
    
    if is_demo_mode; then
        log_info "Starting Postgres AI services (demo mode - including target database)..."
        $compose_cmd -f "$COMPOSE_FILE" up -d 
    else
        log_info "Starting Postgres AI monitoring services (production mode)..."
        log_info "Target demo database not included - add your own PostgreSQL instances to monitor"
        # Start all services except target-db, including host stats monitoring
        $compose_cmd -f "$COMPOSE_FILE" up -d sources-generator sink-postgres sink-prometheus pgwatch-postgres pgwatch-prometheus grafana flask-backend postgres-reports cadvisor node-exporter postgres-exporter
    fi
    
    log_success "Services started!"
    log_info "Host stats monitoring (cAdvisor, Node Exporter, Postgres Exporter) enabled automatically"
    log_info "Waiting for services to be ready..."
    sleep 10
    
    show_access_info
}

# Stop services
stop_services() {
    precheck_for_services
    
    local compose_cmd=$(get_compose_cmd)
    log_info "Stopping Postgres AI services..."
    
    cd "$SCRIPT_DIR"
    $compose_cmd -f "$COMPOSE_FILE" down
    
    log_success "Services stopped"
}

# Restart services
restart_services() {
    stop_services
    sleep 2
    start_services
}

# Show service status
show_status() {
    precheck_for_services
    
    local compose_cmd=$(get_compose_cmd)
    log_info "Postgres AI Monitoring service status:"
    echo
    
    cd "$SCRIPT_DIR"
    $compose_cmd -f "$COMPOSE_FILE" ps
}

# Show logs
show_logs() {
    precheck_for_services
    
    local compose_cmd=$(get_compose_cmd)
    local service="$1"
    
    cd "$SCRIPT_DIR"
    if [ -n "$service" ]; then
        log_info "Showing logs for service: $service"
        $compose_cmd -f "$COMPOSE_FILE" logs -f "$service"
    else
        log_info "Showing logs for all services"
        $compose_cmd -f "$COMPOSE_FILE" logs -f
    fi
}

# Health check
health_check() {
    precheck_for_running_services
    
    log_info "Performing health checks..."
    
    local services=(
        "sink-postgres:55433:PostgreSQL Sink"
        "pgwatch-postgres:58080:PGWatch PostgreSQL"
        "pgwatch-prometheus:58089:PGWatch Prometheus"
        "sink-prometheus:59090:Prometheus"
        "grafana:3000:Grafana"
        "flask-pgss-api:55000:Flask API"
    )
    
    # Add target-db only in demo mode
    if is_demo_mode; then
        services=("target-db:55432:PostgreSQL Target Database" "${services[@]}")
    fi
    
    local all_healthy=true
    
    for service_info in "${services[@]}"; do
        IFS=':' read -r service port description <<< "$service_info"
        
        if curl -s -o /dev/null -w "%{http_code}" "http://localhost:$port" | grep -q "200\|302"; then
            log_success "$description is healthy"
        else
            log_error "$description is not responding"
            all_healthy=false
        fi
    done
    
    if [ "$all_healthy" = true ]; then
        log_success "All services are healthy!"
        show_access_info
    else
        log_warning "Some services are not healthy. Check the logs with: $0 logs"
    fi
}

# List all configured instances
list_instances() {
    check_project_setup
    
    if [ ! -f "$INSTANCES_FILE" ]; then
        log_warning "No instances file found at $INSTANCES_FILE"
        return 1
    fi
    
    log_info "Configured PostgreSQL instances:"
    echo
    
    # Parse instances.yml and display in a readable format
    local in_instance=false
    local name=""
    local conn_str=""
    local is_enabled=""
    local env=""
    local cluster=""
    local node_name=""
    local instance_count=0
    local has_displayed_instance=false
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^-[[:space:]]*name:[[:space:]]*(.+)$ ]]; then
            # New instance starts
            if [ -n "$name" ]; then
                # Display previous instance
                echo "  📍 Instance: $name"
                echo "     Connection: $conn_str"
                echo "     Status: ${is_enabled:-unknown}"
                [ -n "$env" ] && echo "     Environment: $env"
                [ -n "$cluster" ] && echo "     Cluster: $cluster"
                [ -n "$node_name" ] && echo "     Node: $node_name"
                echo
                has_displayed_instance=true
            fi
            name="${BASH_REMATCH[1]}"
            conn_str=""
            is_enabled=""
            env=""
            cluster=""
            node_name=""
            ((instance_count++))
        elif [[ "$line" =~ ^[[:space:]]*conn_str:[[:space:]]*(.+)$ ]]; then
            conn_str="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*is_enabled:[[:space:]]*(.+)$ ]]; then
            is_enabled="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*env:[[:space:]]*(.+)$ ]]; then
            env="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*cluster:[[:space:]]*(.+)$ ]]; then
            cluster="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^[[:space:]]*node_name:[[:space:]]*(.+)$ ]]; then
            node_name="${BASH_REMATCH[1]}"
        fi
    done < "$INSTANCES_FILE"
    
    # Display last instance
    if [ -n "$name" ]; then
        echo "  📍 Instance: $name"
        echo "     Connection: $conn_str"
        echo "     Status: ${is_enabled:-unknown}"
        [ -n "$env" ] && echo "     Environment: $env"
        [ -n "$cluster" ] && echo "     Cluster: $cluster"
        [ -n "$node_name" ] && echo "     Node: $node_name"
        echo
        has_displayed_instance=true
    fi
    
    # Show message if no instances are configured
    if [ "$instance_count" -eq 0 ] || [ "$has_displayed_instance" = false ]; then
        echo "  ❌ No instances configured"
        echo
        log_info "To add PostgreSQL instances for monitoring:"
        echo "  • Interactive mode: $0 add-instance"
        echo "  • Connection string: $0 add-instance 'postgresql://user:pass@host:port/database'"
        echo "  • Example: $0 add-instance 'postgresql://postgres:mypass@localhost:5432/mydb' my-database"
        echo
        
        # Show demo mode info if applicable
        if ! is_demo_mode; then
            log_info "Or use demo mode to test with a sample database:"
            echo "  • $0 reset && $0 quickstart --demo"
        fi
    fi
}

# Parse connection string into components
parse_connection_string() {
    local conn_str="$1"
    
    # postgresql://user:password@host:port/database
    if [[ "$conn_str" =~ ^postgresql://([^:]+):([^@]+)@([^:]+):([0-9]+)/(.+)$ ]]; then
        PG_USER="${BASH_REMATCH[1]}"
        PG_PASSWORD="${BASH_REMATCH[2]}"
        PG_HOST="${BASH_REMATCH[3]}"
        PG_PORT="${BASH_REMATCH[4]}"
        PG_DATABASE="${BASH_REMATCH[5]}"
        return 0
    # postgresql://user:password@host/database (default port)
    elif [[ "$conn_str" =~ ^postgresql://([^:]+):([^@]+)@([^/]+)/(.+)$ ]]; then
        PG_USER="${BASH_REMATCH[1]}"
        PG_PASSWORD="${BASH_REMATCH[2]}"
        PG_HOST="${BASH_REMATCH[3]}"
        PG_PORT="5432"
        PG_DATABASE="${BASH_REMATCH[4]}"
        return 0
    else
        return 1
    fi
}

# Add a new PostgreSQL instance
add_instance() {
    check_project_setup
    
    local conn_str="$1"
    local instance_name="$2"
    
    # If connection string provided, parse it
    if [ -n "$conn_str" ]; then
        log_info "Adding PostgreSQL instance from connection string..."
        
        if ! parse_connection_string "$conn_str"; then
            log_error "Invalid connection string format"
            log_info "Expected format: postgresql://user:password@host:port/database"
            log_info "Example: postgresql://myuser:mypass@localhost:5432/mydb"
            exit 1
        fi
        
        # Use provided instance name or derive from host
        if [ -z "$instance_name" ]; then
            instance_name="$PG_HOST-$PG_DATABASE"
            instance_name=$(echo "$instance_name" | sed 's/[^a-zA-Z0-9-]/-/g')
        fi
        
        # Set default values
        environment="production"
        cluster_name="default"
        node_name="$instance_name"
        is_enabled="true"
        
        log_info "Parsed connection details:"
        echo "  Instance name: $instance_name"
        echo "  Host: $PG_HOST"
        echo "  Port: $PG_PORT"
        echo "  Database: $PG_DATABASE"
        echo "  User: $PG_USER"
        echo
        
    else
        # Interactive mode
        log_info "Adding a new PostgreSQL instance for monitoring (interactive mode)"
        echo
        log_info "Tip: You can also use: $0 add-instance 'postgresql://user:pass@host:port/db' [instance-name]"
        echo
        
        # Collect instance details
        read -p "Instance unique name: " instance_name
        if [ -z "$instance_name" ]; then
            log_error "Instance name is required"
            exit 1
        fi
        
        read -p "PostgreSQL host/IP: " PG_HOST
        if [ -z "$PG_HOST" ]; then
            log_error "PostgreSQL host is required"
            exit 1
        fi
        
        read -p "PostgreSQL port [5432]: " PG_PORT
        PG_PORT=${PG_PORT:-5432}
        
        read -p "Database name: " PG_DATABASE
        if [ -z "$PG_DATABASE" ]; then
            log_error "Database name is required"
            exit 1
        fi
        
        read -p "Username: " PG_USER
        if [ -z "$PG_USER" ]; then
            log_error "Username is required"
            exit 1
        fi
        
        read -s -p "Password: " PG_PASSWORD
        echo
        if [ -z "$PG_PASSWORD" ]; then
            log_error "Password is required"
            exit 1
        fi
        
        environment=${environment:-production}
        
        read -p "Cluster name [default]: " cluster_name
        cluster_name=${cluster_name:-default}
        
        read -p "Node name [$instance_name]: " node_name
        node_name=${node_name:-$instance_name}
        
        read -p "Enable monitoring? [Y/n]: " enable_monitoring
        if [[ $enable_monitoring =~ ^[Nn]$ ]]; then
            is_enabled="false"
        else
            is_enabled="true"
        fi
        
        # Build connection string for verification
        conn_str="postgresql://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DATABASE"
    fi
    
    # Check if instance already exists
    if grep -q "name: $instance_name" "$INSTANCES_FILE" 2>/dev/null; then
        log_error "Instance '$instance_name' already exists"
        exit 1
    fi
    
    # Create new instance configuration
    local new_instance="
- name: $instance_name
  conn_str: postgresql://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DATABASE
  preset_metrics: full
  custom_metrics:
  is_enabled: $is_enabled
  group: default
  custom_tags:
    env: $environment
    cluster: $cluster_name
    node_name: $node_name
    sink_type: ~sink_type~"
    
    # Add to instances file
    echo "$new_instance" >> "$INSTANCES_FILE"
    
    log_success "Instance '$instance_name' added successfully!"
    log_info "You can test the connection with: $0 test-instance $instance_name"
    log_info "Run '$0 update-config' to apply the new configuration"
}

# Remove a PostgreSQL instance
remove_instance() {
    check_project_setup
    
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        log_error "Please specify an instance name to remove"
        log_info "Usage: $0 remove-instance <instance_name>"
        log_info "Use '$0 list-instances' to see available instances"
        exit 1
    fi
    
    if ! grep -q "name: $instance_name" "$INSTANCES_FILE" 2>/dev/null; then
        log_error "Instance '$instance_name' not found"
        exit 1
    fi
    
    log_warning "This will remove instance '$instance_name' from monitoring"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Create temporary file without the instance
        local temp_file=$(mktemp)
        local skip_lines=false
        local instance_started=false
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^-[[:space:]]*name:[[:space:]]*$instance_name$ ]]; then
                skip_lines=true
                instance_started=true
            elif [[ "$line" =~ ^-[[:space:]]*name: ]] && [ "$skip_lines" = true ]; then
                skip_lines=false
                echo "$line" >> "$temp_file"
            elif [ "$skip_lines" = false ]; then
                echo "$line" >> "$temp_file"
            fi
        done < "$INSTANCES_FILE"
        
        mv "$temp_file" "$INSTANCES_FILE"
        log_success "Instance '$instance_name' removed successfully"
        log_info "Run '$0 update-config' to apply the changes"
    else
        log_info "Removal cancelled"
    fi
}

# Test connection to a PostgreSQL instance
test_instance() {
    check_project_setup
    
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        log_error "Please specify an instance name to test"
        log_info "Usage: $0 test-instance <instance_name>"
        log_info "Use '$0 list-instances' to see available instances"
        exit 1
    fi
    
    # Extract connection string for the instance
    local conn_str=""
    local in_instance=false
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^-[[:space:]]*name:[[:space:]]*$instance_name$ ]]; then
            in_instance=true
        elif [[ "$line" =~ ^-[[:space:]]*name: ]] && [ "$in_instance" = true ]; then
            break
        elif [[ "$line" =~ ^[[:space:]]*conn_str:[[:space:]]*(.+)$ ]] && [ "$in_instance" = true ]; then
            conn_str="${BASH_REMATCH[1]}"
            break
        fi
    done < "$INSTANCES_FILE"
    
    if [ -z "$conn_str" ]; then
        log_error "Instance '$instance_name' not found or missing connection string"
        exit 1
    fi
    
    log_info "Testing connection to instance: $instance_name"
    log_info "Connection string: $conn_str"
    
    # Test connection using Docker PostgreSQL client
    if command -v psql &> /dev/null; then
        echo "SELECT version();" | psql "$conn_str" 2>/dev/null
        if [ $? -eq 0 ]; then
            log_success "Connection to '$instance_name' successful!"
        else
            log_error "Connection to '$instance_name' failed!"
        fi
    else
        log_warning "psql not found locally. Testing via Docker..."
        local compose_cmd=$(get_compose_cmd)
        cd "$SCRIPT_DIR"
        
        if $compose_cmd -f "$COMPOSE_FILE" exec -T target-db psql "$conn_str" -c "SELECT version();" 2>/dev/null; then
            log_success "Connection to '$instance_name' successful!"
        else
            log_error "Connection to '$instance_name' failed!"
            log_info "Make sure the database is accessible and credentials are correct"
        fi
    fi
}

# Future: Generate reports functionality will be added here

# Show configuration
show_config() {
    check_project_setup
    
    log_info "Current configuration:"
    echo
    echo "Project Directory: $SCRIPT_DIR"
    echo "Docker Compose File: $COMPOSE_FILE"
    echo "Instances File: $INSTANCES_FILE"
    echo
    
    if [ -f "$INSTANCES_FILE" ]; then
        log_info "Instances configuration:"
        cat "$INSTANCES_FILE"
    else
        log_warning "Instances file not found"
    fi
}

# Update project from repository
update_project() {
    check_project_setup
    
    log_info "Updating Postgres AI monitoring project to latest version..."
    
    # Check if we're in a git repository
    if [ ! -d "$SCRIPT_DIR/.git" ]; then
        log_error "Not a git repository - cannot update"
        log_info "This project was likely installed from a downloaded archive"
        log_info "To update, you'll need to:"
        echo "  1. Backup your configuration: cp instances.yml instances.yml.backup"
        echo "  2. Backup any custom configs in config/ directory"
        echo "  3. Run a fresh installation: $0 install"
        echo "  4. Restore your configuration: cp instances.yml.backup instances.yml"
        exit 1
    fi
    
    # Check if there are uncommitted changes
    if ! git diff --quiet || ! git diff --cached --quiet; then
        log_warning "You have uncommitted changes in the repository"
        git status --porcelain
        echo
        log_warning "These changes will be stashed before updating"
        read -p "Continue with update? (y/N): " -n 1 -r
        echo
        
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Update cancelled"
            exit 0
        fi
        
        log_info "Stashing local changes..."
        git stash push -m "Auto-stash before update $(date)"
    fi
    
    # Get current branch/commit info
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    local current_commit=$(git rev-parse HEAD)
    
    log_info "Current branch: $current_branch"
    log_info "Current commit: ${current_commit:0:8}"
    
    # Fetch latest changes
    log_info "Fetching latest changes from repository..."
    if ! git fetch origin; then
        log_error "Failed to fetch from repository"
        log_info "Check your internet connection and repository access"
        exit 1
    fi
    
    # Check if updates are available
    local remote_commit=$(git rev-parse origin/$current_branch)
    if [ "$current_commit" = "$remote_commit" ]; then
        log_success "Project is already up to date!"
        return 0
    fi
    
    log_info "Updates available. Latest commit: ${remote_commit:0:8}"
    
    # Show what will be updated
    log_info "Changes since current version:"
    git log --oneline $current_commit..origin/$current_branch | head -10
    
    echo
    read -p "Apply these updates? (y/N): " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Update cancelled"
        exit 0
    fi
    
    # Check if services are running and offer to stop them
    local compose_cmd=$(get_compose_cmd)
    local running_services
    running_services=$($compose_cmd -f "$COMPOSE_FILE" ps --services --filter "status=running" 2>/dev/null || true)
    
    if [ -n "$running_services" ]; then
        log_warning "Services are currently running:"
        echo "$running_services" | sed 's/^/  ✅ /'
        echo
        log_warning "It's recommended to stop services before updating"
        read -p "Stop services before update? (Y/n): " -n 1 -r
        echo
        
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            log_info "Stopping services..."
            $compose_cmd -f "$COMPOSE_FILE" down
            local should_restart=true
        else
            local should_restart=false
        fi
    else
        local should_restart=false
    fi
    
    # Perform the update
    log_info "Updating project files..."
    if git pull origin $current_branch; then
        log_success "Project updated successfully!"
        
        # Check if there were any stashed changes to restore
        if git stash list | grep -q "Auto-stash before update"; then
            log_info "Attempting to restore your local changes..."
            if git stash pop; then
                log_success "Local changes restored successfully"
            else
                log_warning "Some conflicts occurred while restoring local changes"
                log_info "Your changes are still available in git stash"
                log_info "Use 'git stash list' and 'git stash show' to review them"
            fi
        fi
        
        # Update configuration if services were running
        if [ "$should_restart" = true ]; then
            echo
            log_info "Updating configuration and restarting services..."
            update_config
            sleep 2
            start_services
        else
            echo
            log_info "Configuration update recommended. Run: $0 update-config"
        fi
        
        # Show what was updated
        echo
        log_info "Update completed! Changes applied:"
        git log --oneline $current_commit..HEAD
        
    else
        log_error "Failed to update project"
        log_info "You may need to resolve conflicts manually"
        exit 1
    fi
}

# Update configuration
update_config() {
    check_project_setup
    
    log_info "Updating configuration files..."
    
    # Generate sources files
    local compose_cmd=$(get_compose_cmd)
    cd "$SCRIPT_DIR"
    $compose_cmd -f "$COMPOSE_FILE" run --rm sources-generator
    
    # Check if containers are running before trying to restart them
    local running_containers
    running_containers=$($compose_cmd -f "$COMPOSE_FILE" ps --services --filter "status=running" 2>/dev/null || true)
    
    if echo "$running_containers" | grep -q "pgwatch-postgres"; then
        log_info "Restarting pgwatch-postgres to apply new configuration..."
        $compose_cmd -f "$COMPOSE_FILE" restart pgwatch-postgres
    else
        log_info "pgwatch-postgres not running - configuration will be applied when it starts"
    fi
    
    if echo "$running_containers" | grep -q "pgwatch-prometheus"; then
        log_info "Restarting pgwatch-prometheus to apply new configuration..."
        $compose_cmd -f "$COMPOSE_FILE" restart pgwatch-prometheus
    else
        log_info "pgwatch-prometheus not running - configuration will be applied when it starts"
    fi
    
    log_success "Configuration updated"
}

# Reset specific service volume
reset_service_volume() {
    precheck_for_services
    
    local service="$1"
    
    if [ -z "$service" ]; then
        log_error "Please specify a service name to reset"
        log_info "Usage: $0 reset <service>"
        log_info "Available services: any service with associated data volumes"
        exit 1
    fi
    
    # Find volume(s) with service name pattern
    local service_pattern=$(echo "$service" | tr '-' '_')
    local volume_names
    
    # Try multiple patterns to handle different volume naming conventions:
    # 1. Direct match: service_name_data
    volume_names=$(docker volume ls --format "{{.Name}}" | grep -E "^${service_pattern}_data$" || true)
    
    # 2. With project prefix: project_service_name_data  
    if [ -z "$volume_names" ]; then
        volume_names=$(docker volume ls --format "{{.Name}}" | grep -E "_${service_pattern}_data$" || true)
    fi
    
    # 3. Contains service name pattern: *service_name*_data
    if [ -z "$volume_names" ]; then
        volume_names=$(docker volume ls --format "{{.Name}}" | grep -E "${service_pattern}.*_data$" || true)
    fi
    
    # 4. Case-insensitive fallback
    if [ -z "$volume_names" ]; then
        # Try alternative pattern matching
        volume_names=$(docker volume ls --format "{{.Name}}" | grep -i "$service" | grep "_data$" || true)
    fi
    
    if [ -z "$volume_names" ]; then
        log_error "No volumes found for service '$service'"
        log_info "Available volumes:"
        docker volume ls --format "  {{.Name}}" | grep "_data$" || echo "  No data volumes found"
        exit 1
    fi
    
    local volume_count=$(echo "$volume_names" | wc -l)
    if [ "$volume_count" -gt 1 ]; then
        log_warning "Multiple volumes found for service '$service':"
        echo "$volume_names" | sed 's/^/  /'
        log_warning "All volumes will be deleted!"
    fi
    
    log_warning "This will stop '$service', delete ALL its data, and restart it!"
    if [ "$volume_count" -gt 1 ]; then
        log_warning "Volumes to be deleted:"
        echo "$volume_names" | sed 's/^/  /'
    else
        log_warning "Volume to be deleted: $volume_names"
    fi
    read -p "Are you sure? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local compose_cmd=$(get_compose_cmd)
        cd "$SCRIPT_DIR"
        
        log_info "Stopping and removing service: $service"
        $compose_cmd -f "$COMPOSE_FILE" stop "$service"
        $compose_cmd -f "$COMPOSE_FILE" rm -f "$service"
        
        # Also check for any other containers that might be using the volume(s)
        if [ "$volume_count" -gt 1 ]; then
            log_info "Removing volumes..."
            echo "$volume_names" | while read -r volume_name; do
                if [ -n "$volume_name" ]; then
                    log_info "Removing volume: $volume_name"
                    
                    # Check if any containers are still using this volume
                    local containers_using_volume
                    containers_using_volume=$(docker ps -a --filter "volume=$volume_name" --format "{{.Names}}" 2>/dev/null || true)
                    
                    if [ -n "$containers_using_volume" ]; then
                        log_warning "Stopping containers still using volume '$volume_name': $containers_using_volume"
                        echo "$containers_using_volume" | xargs -r docker stop 2>/dev/null || true
                        echo "$containers_using_volume" | xargs -r docker rm 2>/dev/null || true
                    fi
                    
                    docker volume rm "$volume_name" 2>/dev/null || {
                        log_warning "Volume '$volume_name' not found or still in use"
                        log_info "You may need to manually remove it: docker volume rm $volume_name"
                    }
                fi
            done
        else
            log_info "Removing volume: $volume_names"
            
            # Check if any containers are still using this volume
            local containers_using_volume
            containers_using_volume=$(docker ps -a --filter "volume=$volume_names" --format "{{.Names}}" 2>/dev/null || true)
            
            if [ -n "$containers_using_volume" ]; then
                log_warning "Stopping containers still using volume '$volume_names': $containers_using_volume"
                echo "$containers_using_volume" | xargs -r docker stop 2>/dev/null || true
                echo "$containers_using_volume" | xargs -r docker rm 2>/dev/null || true
            fi
            
            docker volume rm "$volume_names" 2>/dev/null || {
                log_warning "Volume '$volume_names' not found or still in use"
                log_info "You may need to manually remove it: docker volume rm $volume_names"
            }
        fi
        
        log_info "Starting service: $service"
        $compose_cmd -f "$COMPOSE_FILE" up -d "$service"
        
        log_success "Service '$service' has been reset successfully!"
        log_info "All data for '$service' has been cleared and service is restarting"
        
        # Special messages for specific services
        case "$service" in
            "target-db")
                log_info "Target database has been reset to initial state"
                ;;
            "sink-postgres")
                log_info "PostgreSQL metrics sink has been reset - all historical metrics deleted"
                ;;
            "sink-prometheus")
                log_info "Prometheus metrics sink has been reset - all historical metrics deleted"
                ;;
            "grafana")
                log_info "Grafana has been reset - all dashboards and settings restored to default"
                log_info "You may need to reconfigure Grafana password with: $0 generate-grafana-password"
                ;;
        esac
    else
        log_info "Reset cancelled"
    fi
}

# Reset environment
reset_environment() {
    precheck_for_services
    
    log_warning "This will stop all services and remove all data!"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local compose_cmd=$(get_compose_cmd)
        cd "$SCRIPT_DIR"
        
        log_info "Stopping services and removing data..."
        
        # Stop and remove containers with volumes
        $compose_cmd -f "$COMPOSE_FILE" down -v --remove-orphans
        
        # Force remove any remaining containers by name pattern
        local remaining_containers
        remaining_containers=$(docker ps -a --filter "name=postgres-ai-mon" --format "{{.Names}}" 2>/dev/null || true)
        
        if [ -n "$remaining_containers" ]; then
            log_info "Removing any remaining containers..."
            echo "$remaining_containers" | xargs -r docker stop 2>/dev/null || true
            echo "$remaining_containers" | xargs -r docker rm 2>/dev/null || true
        fi
        
        # Remove any orphaned volumes
        docker volume ls --filter "name=postgres-ai-mon" --format "{{.Name}}" | xargs -r docker volume rm 2>/dev/null || true
        
        # Remove any generated config files
        rm -f "$SCRIPT_DIR/config/pgwatch-postgres/sources.yml"
        rm -f "$SCRIPT_DIR/config/pgwatch-prometheus/sources.yml"
        
        log_success "Environment reset completed - all containers and data removed"
    else
        log_info "Reset cancelled"
    fi
}

# Clean up
cleanup() {
    log_info "Cleaning up..."
    
    # Remove Python cache
    find "$SCRIPT_DIR" -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
    find "$SCRIPT_DIR" -name "*.pyc" -type f -delete 2>/dev/null || true
    
    # Clean Docker resources
    docker system prune -f
    
    log_success "Cleanup completed"
}

# Open shell in container
open_shell() {
    precheck_for_running_services
    
    local service="$1"
    
    if [ -z "$service" ]; then
        log_error "Please specify a service name"
        log_info "Available services: target-db, sink-postgres, sink-prometheus, pgwatch-postgres, pgwatch-prometheus, grafana, flask-pgss-api, postgres-reports"
        exit 1
    fi
    
    local compose_cmd=$(get_compose_cmd)
    cd "$SCRIPT_DIR"
    
    if [ "$service" = "target-db" ] || [ "$service" = "sink-postgres" ]; then
        $compose_cmd -f "$COMPOSE_FILE" exec "$service" psql -U postgres
    else
        $compose_cmd -f "$COMPOSE_FILE" exec "$service" /bin/sh
    fi
}

# Show access information
show_access_info() {
    echo
    log_info "Technical service URLs (for advanced users):"
    echo "  PGWatch Postgres:   http://localhost:58080"
    echo "  PGWatch Prometheus: http://localhost:58089"
    echo "  Prometheus:         http://localhost:59090"
    echo "  Flask API:          http://localhost:55000"
    echo "  cAdvisor (host stats): http://localhost:58081"
    echo "  Node Exporter:      http://localhost:59100/metrics"
    echo "  Postgres Exporter:  http://localhost:59187/metrics"
    
    # Show target database only in demo mode
    if is_demo_mode; then
        echo "  Target Database:    postgresql://postgres:postgres@localhost:55432/target_database"
    fi
    
    echo "  Sink Database:      postgresql://postgres:postgres@localhost:55433/postgres"
    echo
    
    # Show reports information
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ] && grep -q "^api_key=" "$SCRIPT_DIR/.pgwatch-config"; then
        log_info "PostgreSQL reports will be generated every 24 hours and uploaded to Postgres AI"
        local api_key=$(grep "^api_key=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        local masked_key="${api_key:0:4}$( printf '%*s' $((${#api_key} - 8)) '' | tr ' ' '*' )${api_key: -4}"
        echo "  API Key:            $masked_key"
    else
        log_info "PostgreSQL reports will be generated every 24 hours (no API key configured for upload)"
        log_info "Use '$0 add-key <api_key>' to enable automatic report uploads"
    fi
    echo
    
    if ! is_demo_mode; then
        log_info "Production mode - no demo database running"
        log_info "Use '$0 list-instances' to see your configured PostgreSQL instances"
    fi
    
    # Highlight the main access point
    echo
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${GREEN}🚀 MAIN ACCESS POINT - Start here:${NC}"
    echo -e "${GREEN}   Grafana Dashboard: http://localhost:3000${NC}"
    
    # Show custom credentials if available
    if [ -f "$SCRIPT_DIR/.pgwatch-config" ]; then
        local grafana_password=$(grep "^grafana_password=" "$SCRIPT_DIR/.pgwatch-config" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$grafana_password" ]; then
            echo -e "${GREEN}   Login: monitor / $grafana_password${NC}"
        else
            echo -e "${GREEN}   Login: monitor / demo${NC}"
        fi
    else
        echo -e "${GREEN}   Login: monitor / demo${NC}"
    fi
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Main command handling
main() {
    case "${1:-help}" in
        "quickstart")
            shift
            quickstart_setup "$@"
            ;;
        "install")
            install_project "$2"
            ;;
        "start")
            start_services
            ;;
        "stop")
            stop_services
            ;;
        "restart")
            restart_services
            ;;
        "status")
            show_status
            ;;
        "logs")
            show_logs "$2"
            ;;
        "health")
            health_check
            ;;
        "config")
            show_config
            ;;
        "update-config")
            update_config
            ;;
        "update")
            update_project
            ;;
        "reset")
            if [ -n "$2" ]; then
                reset_service_volume "$2"
            else
                reset_environment
            fi
            ;;
        "clean")
            cleanup
            ;;
        "shell")
            open_shell "$2"
            ;;
        "check")
            system_check
            ;;
        "list-instances")
            list_instances
            ;;
        "add-instance")
            add_instance "$2" "$3"
            ;;
        "remove-instance")
            remove_instance "$2"
            ;;
        "test-instance")
            test_instance "$2"
            ;;
        "add-key")
            add_api_key "$2"
            ;;
        "show-key")
            show_api_key
            ;;
        "remove-key")
            remove_api_key
            ;;
        "generate-grafana-password")
            generate_grafana_password
            ;;
        "show-grafana-credentials")
            show_grafana_credentials
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        *)
            log_error "Unknown command: $1"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 